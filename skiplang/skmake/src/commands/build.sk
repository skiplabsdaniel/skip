module Skmake;

fun build(): (Cli.Command, (Skargo.GlobalContext, Cli.ParseResults) ~> void) {
  (Skargo.kBuildCommand, execBuild)
}

fun execBuild(gctx: Skargo.GlobalContext, args: Cli.ParseResults): void {
  withStateAndTimer(
    () -> {
      checkAndRunContext(context ~> {
        context.setGlobal("Skargo.Console", ConsoleFile(gctx.console));
        manifest_path = Skargo.root_manifest(args, gctx);
        config = Skargo.build_config{
          target_opt => args.maybeGetString("target", false),
          profile_opt => args.maybeGetString("profile"),
          release => args.getBool("release"),
          skc_extra_options => args.getArray("skcopt", Some(Array[])),
        };
        filter = BuildFilter(
          args.getBool("lib", Some(false)),
          args.getBool("bins", Some(false)),
          SortedSet::createFromItems(args.getArray("bin", Some(Array[]))),
        );
        context.getPersistent(kEnvProperty).map(Environment::type) match {
        | Some(env) -> env.build(context, manifest_path, config, filter)
        | _ -> throw CommandError("Execution environment not found")
        };
      });
    },
    args,
    (t, failure) -> {
      if (!failure) {
        gctx.console.status("Finished", `Build target in ${t}s`)
      } else {
        gctx.console.status(
          "Finished with error(s)",
          `Build target in ${t}s`,
          Skargo.Console::kErrorColor,
        )
      }
    },
  ) match {
  | Success _ -> void
  | Failure(e) ->
    print_error(e.getMessage());
    skipExit(2)
  }
}

module end;
