module alias SK = SKStore;

module Skmake;

const kEnvProperty: String = "Skmake.Environment";

class TimedFile(filename: String, modified: Int) extends SK.File uses Orderable

class Files(files: Array<TimedFile>) extends SK.File

base class PackageRef extends SK.File {
  children =
  | Package(package: Skargo.Package)
  | PackageLink(path: String)

  static fun bType(file: SK.File): PackageRef {
    file match {
    | x @ PackageRef _ -> x
    | _ -> invariant_violation("Must be a Skmake.PackageRef")
    }
  }
}

class TimedPackage(package: Skargo.Package, time: Int) extends SK.File

class PackageId(
  name: String,
  version: Semver.Version,
  path: String,
) extends SK.Key {
  //
  static fun create(package: Skargo.Package): PackageId {
    id = package.manifest.package_id;
    PackageId(id.name, id.version, package.root())
  }
}

class BytesFile(bytes: Vector<UInt8>) extends SK.File

class ConsoleFile(console: Skargo.Console) extends SK.File

class Options{
  profile: String,
  output: String,
  arch: Skargo.TargetArch,
  check: Bool = false,
  noStd: Bool = false,
  isLib: Bool = false,
}

class BuildScriptError(error: String) extends .Exception {
  fun getMessage(): String {
    this.error
  }
}

class HostTargetError(error: String) extends .Exception {
  fun getMessage(): String {
    this.error
  }
}

class CommandError(error: String) extends .Exception {
  fun getMessage(): String {
    this.error
  }
}

class Dependency(
  dep: Skargo.Dependency,
  buildInfo: ?BuildInfo = None(),
) extends SK.Key {
  fun toString(): String {
    `${this.dep.name}@${this.dep.req}`
  }
}

class BuildScriptOutput(bso: Skargo.BuildScriptOutput) extends SK.File

class BuildSources{
  sources_: SortedSet<String> = SortedSet[],
  env_: SortedSet<(String, String)> = SortedSet[],
  preambles_: SortedSet<String> = SortedSet[],
  link_args_: SortedSet<String> = SortedSet[],
  libraries_: Set<Array<String>> = Set[],
} extends SK.File {
  //
  static fun fromBuildScriptOutput(
    bso: Skargo.BuildScriptOutput,
  ): BuildSources {
    sources_ = SortedSet[];
    bso.extra_sources.each(f -> !sources_ = sources_.set(f));
    env_ = SortedSet[];
    bso.env.each(e -> !env_ = env_.set(e));
    preambles_ = SortedSet[];
    bso.preambles.each(p -> !preambles_ = preambles_.set(p));
    link_args_ = SortedSet[];
    bso.link_args.each(l -> !link_args_ = link_args_.set(l));
    libraries_ = Set[bso.libraries];
    BuildSources{sources_, env_, preambles_, link_args_, libraries_}
  }

  fun getLastModificationTime(): Int {
    mtime = this.sources_.reduce(
      (acc, s) -> {
        time = FileSystem.getLastModificationTime(s);
        if (time > acc) time else acc
      },
      0,
    );
    this.libraries_.reduce(
      (acc1, a) -> {
        time1 = a.reduce(
          (acc2, l) -> {
            time2 = FileSystem.getLastModificationTime(l);
            if (time2 > acc2) time2 else acc2
          },
          0,
        );
        if (time1 > acc1) time1 else acc1
      },
      mtime,
    );
  }

  fun union(other: BuildSources): BuildSources {
    BuildSources{
      sources_ => this.sources_.union(other.sources_),
      env_ => this.env_.union(other.env_),
      preambles_ => this.preambles_.union(other.preambles_),
      link_args_ => this.link_args_.union(other.link_args_),
      libraries_ => this.libraries_.union(other.libraries_),
    }
  }

  fun sources(files: Array<String>): BuildSources {
    files.each(f -> !this.sources_ = this.sources_.set(f));
    this
  }

  fun forCheck(): BuildSources {
    this with {link_args_ => SortedSet[], libraries_ => Set[]}
  }
}

class BuildData(buildInfo: BuildInfo, withTests: Bool) extends SK.Key

base class Command(buildInfo: BuildInfo) extends SK.Key {
  children =
  | Check()
  | Build(target: Skargo.Target)

  static fun bKeyType(key: SK.Key): Command {
    key match {
    | x @ Command _ -> x
    | _ -> invariant_violation("Must be a Skmake.Command")
    }
  }
}

class BuildInfo(
  arch: Skargo.TargetArch,
  host: Skargo.TargetArch,
  profile: String,
) uses Orderable {
  fun targetDir(): String {
    `target/${this.arch}/${this.profile}`
  }
}

class Script(package: PackageId, name: String) extends SK.Key

class TargetedScript(script: Script, buildInfo: BuildInfo) extends SK.Key

class BuildFilter(
  lib_only: Bool,
  all_bins: Bool,
  bins: SortedSet<String>,
  all_tests: Bool,
  all_targets: Bool,
) {
  //
  fun check(target: Skargo.Target): Bool {
    if (this.lib_only) {
      target.kind match {
      | Skargo.LibTarget _ -> true
      | _ -> false
      }
    } else if (this.all_bins) {
      target.kind match {
      | Skargo.BinTarget _ -> true
      | _ -> false
      }
    } else if (!this.bins.isEmpty()) {
      target.kind match {
      | Skargo.BinTarget _ -> this.bins.contains(target.name)
      | _ -> false
      }
    } else if (this.all_tests) {
      target.kind match {
      | Skargo.TestTarget _ -> true
      | _ -> false
      }
    } else {
      target.kind match {
      | Skargo.LibTarget(Skargo.LibraryTypeSklib _)
      | Skargo.BinTarget _ ->
        true
      | Skargo.TestTarget _ -> this.all_targets
      | _ -> false
      }
    }
  }
}

class Environment(
  toml: SK.EHandle<SKStore.UnitID, TimedFile>,
  pckHdl: SK.EHandle<SKStore.UnitID, TimedPackage>,
  commands: SK.EHandle<Command, SK.IntFile>,
  sources: SK.EHandle<BuildData, BuildSources>,
) extends SK.File {
  //
  fun check(
    context: mutable SK.Context,
    filename: String,
    config: Skargo.BuildConfig,
  ): Result<void, .Exception> {
    profile = config.requested_profile;
    check = Check(
      BuildInfo(
        config.requested_arch
          .map(tt -> Skargo.TargetArchTriple(tt))
          .default(Skargo.TargetArchHost()),
        Skargo.TargetArchTriple(get_host_target()),
        profile,
      ),
    );
    this.checkProject(context, filename)?;
    this.updateCommands(context, Array[check])?;
    console = getConsole(context);
    package = this.pckHdl.get(context, SKStore.UnitID::singleton).package;
    buildSources = this.sources.get(context, BuildData(check.buildInfo, true));
    output = check.buildInfo.targetDir();
    Result::guard(() -> {
      skc_ = Skargo.Skc(Environ.varOpt("SKC").default("skc"), Array[]);
      _ = skc(
        skc_.process(),
        "check",
        console,
        Skargo.Target(Skargo.CustomBuildTarget(), "check", Array[]),
        package,
        buildSources.forCheck(),
        Options{
          output,
          profile => check.buildInfo.profile,
          arch => check.buildInfo.arch,
          check => true,
          noStd => true,
        },
        "check",
      )
    });
  }

  fun build(
    context: mutable SK.Context,
    filename: String,
    config: Skargo.BuildConfig,
    filter: BuildFilter,
  ): Result<Array<String>, .Exception> {
    this.checkProject(context, filename)?;
    profile = config.requested_profile;
    package = this.pckHdl.get(context, SKStore.UnitID::singleton).package;
    buildInfo = BuildInfo(
      config.requested_arch
        .map(tt -> Skargo.TargetArchTriple(tt))
        .default(Skargo.TargetArchHost()),
      Skargo.TargetArchTriple(get_host_target()),
      profile,
    );
    builds = package.manifest.targets
      .map(target -> {
        if (filter.check(target)) {
          Some(Build(target, buildInfo))
        } else {
          None()
        }
      })
      .filterNone();
    this.updateCommands(context, builds)?;
    console = getConsole(context);
    outputs = mutable Vector[];
    for (build in builds) {
      buildSources = this.sources.get(
        context,
        BuildData(build.buildInfo, build.target.kind is Skargo.TestTarget _),
      );
      outputDir = build.buildInfo.targetDir();
      output = Result::guard(() -> {
        skc_ = Skargo.Skc(Environ.varOpt("SKC").default("skc"), Array[]);
        skc(
          skc_.process(),
          build.target.name,
          console,
          build.target,
          package,
          buildSources,
          Options{
            output => outputDir,
            profile => build.buildInfo.profile,
            arch => build.buildInfo.arch match {
            | Skargo.TargetArchHost() -> build.buildInfo.host
            | arch -> arch
            },
            check => false,
            noStd => true,
          },
          `build_${build.target.name}`,
        )
      })?;
      output.each(outputs.push)
    };
    Success(outputs.toArray())
  }

  private fun checkProject(
    context: mutable SK.Context,
    filename: String,
  ): Result<void, .Exception> {
    Result::guard(() -> {
      mtime = Time.time();
      this.toml.writeArray(
        context,
        SKStore.UnitID::singleton,
        Array[TimedFile(filename, mtime)],
      );
      context.update();
    });
  }

  private fun updateCommands(
    context: mutable SK.Context,
    commands: Array<Command>,
  ): Result<void, .Exception> {
    Result::guard(() -> {
      mtime = Time.time();
      commands.each(command ->
        this.commands.writeArray(context, command, Array[SK.IntFile(mtime)])
      );
      context.update();
    });
  }
}

fun getConsole(context: mutable SK.Context): Skargo.Console {
  context
    .getGlobal("Skargo.Console")
    .map(ConsoleFile::type)
    .map(c ~> c.console)
    .default(Skargo.Console::create(Skargo.VerbosityNormal(), "auto"));
}

class PackageData(time: Int, links: SortedSet<String>) extends SK.File {
  fun addLink(link: String): PackageData {
    this with {links => this.links.set(link)};
  }
}

fun fillPackages(
  context: mutable SK.Context,
  package: Skargo.Package,
  data: SortedMap<PackageId, PackageData>,
  loader: (mutable SK.Context, Skargo.SourceId) ~> Skargo.Package,
  withDev: Bool = true,
): SortedMap<PackageId, PackageData> {
  packageId = PackageId::create(package);
  optExisting = data.maybeGet(packageId);
  manifest = package.manifest;
  source = manifest.package_id.source_id;
  sourcePath = source.kind match {
  | Skargo.PathSource() -> source.url
  };
  optExisting match {
  | Some(d) ->
    if (sourcePath != package.root()) {
      !d = d.addLink(sourcePath);
      !data = data.set(packageId, d)
    };
    return data
  | None() -> void
  };
  !data = data.set(
    packageId,
    PackageData(
      FileSystem.getLastModificationTime(packageId.path),
      if (sourcePath != package.root()) SortedSet[sourcePath] else SortedSet[],
    ),
  );
  package.manifest.dependencies.each(dependency -> {
    if (!withDev && dependency.kind is Skargo.DevelopmentDep()) return void;
    !data = fillPackages(
      context,
      loader(context, dependency.source_id),
      data,
      loader,
      false,
    )
  });
  data
}

fun buildBuildInfoCollector(
  context: mutable SK.Context,
  dirName: SK.DirName,
  packageGetter: (mutable SK.Context, Skargo.Dependency) ~> Skargo.Package,
  buildScriptOutputGetter: (
    mutable SK.Context,
    TargetedScript,
  ) ~> Skargo.BuildScriptOutput,
): SKStore.LHandle<Dependency, BuildSources> {
  SKStore.LHandle::create(
    Dependency::keyType,
    BuildSources::type,
    context,
    dirName,
    (ctx, self, key) ~> {
      package = packageGetter(ctx, key.dep);
      path = package.root();
      buildSources = BuildSources{};
      package.manifest.targets.each(target -> {
        if (target.kind is Skargo.LibTarget(Skargo.LibraryTypeSklib())) {
          !buildSources = buildSources.sources(
            target.srcs.map(src -> Path.join(path, src)),
          )
        } else if (target.kind is Skargo.CustomBuildTarget()) {
          key.buildInfo.each(bi -> {
            packageId = PackageId::create(package);
            ts = TargetedScript(Script(packageId, target.name), bi);
            bso = buildScriptOutputGetter(ctx, ts);
            cbt = BuildSources::fromBuildScriptOutput(bso);
            !buildSources = buildSources.union(cbt)
          });
        }
      });
      package.manifest.dependencies.each(dep -> {
        if (
          dep.kind is Skargo.DevelopmentDep() ||
          dep.kind is Skargo.BuildDep()
        ) return void;
        !buildSources = buildSources.union(
          self.get(ctx, Dependency(dep, key.buildInfo)),
        )
      });
      Array[buildSources]
    },
  );
}

fun init(context: mutable SK.Context, dirName: SK.DirName): void {
  skc_ = Skargo.Skc(Environ.varOpt("SKC").default("skc"), Array[]);
  loadPackage = SKStore.LHandle::create(
    SK.SID::keyType,
    Package::type,
    context,
    dirName.sub("loader"),
    (_, _self, key) ~> {
      Array[Package(Skargo.Package::read(key.value))]
    },
  );
  tomlHdl = context.mkdir(
    SKStore.UnitID::keyType,
    TimedFile::type,
    dirName.sub("toml"),
  );
  commandsHdl = context.mkdir(
    Command::bKeyType,
    SK.IntFile::type,
    dirName.sub("commands"),
  );
  pckHdl = tomlHdl.map(
    SKStore.UnitID::keyType,
    TimedPackage::type,
    context,
    dirName.sub("package"),
    (ctx, writer, key, it) ~> {
      tfile = it.first;
      package = loadPackage.get(ctx, SK.SID(Path.join(tfile.filename)));
      writer.set(key, TimedPackage(package.package, tfile.modified))
    },
  );
  rootPathHdl = pckHdl.map(
    SKStore.UnitID::keyType,
    SK.StringFile::type,
    context,
    dirName.sub("package/path"),
    (_ctx, writer, key, it) ~> {
      writer.set(key, SK.StringFile(it.first.package.root()))
    },
  );
  allPackagesData = pckHdl.map(
    PackageId::keyType,
    PackageData::type,
    context,
    dirName.sub("packages/ids"),
    (ctx, writer, _, it) ~> {
      data = fillPackages(
        ctx,
        it.first.package,
        SortedMap<PackageId, PackageData>[],
        (context, source) ~> {
          path = source.kind match {
          | Skargo.PathSource() -> Path.join(source.url, Skargo.kManifestFile)
          };
          loadPackage.get(context, SK.SID(path)).package
        },
      );
      data.items().each(item -> writer.set(item.i0, item.i1))
    },
  );
  allPackages = allPackagesData.map(
    PackageId::keyType,
    Package::type,
    context,
    dirName.sub("packages"),
    (ctx, writer, key, _) ~> {
      package = loadPackage.get(
        ctx,
        SK.SID(Path.join(key.path, Skargo.kManifestFile)),
      );
      writer.set(key, package)
    },
  );
  // To create dependency on file modification time
  allFiles = allPackages.map(
    SK.SID::keyType,
    SK.IntFile::type,
    context,
    dirName.sub("packages/files"),
    (ctx, writer, _, it) ~> {
      it.toArray().each(package -> {
        manifest = package.package.manifest;
        path = package.package.root();
        // Get dependence to update all fill data
        _ = tomlHdl.get(ctx, SKStore.UnitID::singleton);
        manifest.targets.each(target -> {
          if (
            target.kind is Skargo.LibTarget(Skargo.LibraryTypeSklib()) ||
            target.kind is Skargo.CustomBuildTarget()
          ) {
            target.srcs.each(src -> {
              file = Path.join(path, src);
              mtile = FileSystem.getLastModificationTime(file);
              writer.set(SK.SID(file), SK.IntFile(mtile))
            })
          }
        });
      })
    },
  );
  _ = allFiles.map(
    SK.SID::keyType,
    SK.IntFile::type,
    context,
    dirName.sub("packages/files/check"),
    (ctx, writer, key, it) ~> {
      console = getConsole(ctx);
      console.verbose(() -> {
        console.status("Modified", key.value)
      });
      writer.set(key, it.first)
    },
  );
  allPackageByName = allPackages
    .map(
      SK.SID::keyType,
      Package::type,
      context,
      dirName.sub("packages/byname"),
      (_ctx, writer, key, it) ~> {
        writer.set(SK.SID(key.name), it.first)
      },
    )
    .map(
      SK.SID::keyType,
      Package::type,
      context,
      dirName.sub("allPackages/sorted"),
      (_ctx, writer, key, it) ~> {
        array = it
          .toArray()
          .sortedBy(
            p ~> p.package.manifest.package_id.version,
            (v1, v2) ~> v2.compare(v1),
          );
        writer.setArray(key, array)
      },
    );
  collectBuildInfo = buildBuildInfoCollector(
    context,
    dirName.sub("buildInfos"),
    (ctx, dep) ~> {
      allPackageByName.getArray(ctx, SK.SID(dep.name)).filter(p ->
        dep.req.matches(p.package.manifest.package_id.version)
      )[0].package
    },
    (_ctx, _ts) ~>
      invariant_violation("Build script of build script nor implemented")
    ,
  );
  builds = allPackages.map(
    Script::keyType,
    BuildSources::type,
    context,
    dirName.sub("builds"),
    (ctx, writer, _, it) ~> {
      package = it.first.package;
      manifest = package.manifest;
      source = manifest.package_id.source_id;
      path = source.kind match {
      | Skargo.PathSource() -> source.url
      };
      package.manifest.targets
        .filter(t -> t.kind is Skargo.CustomBuildTarget())
        .each(build -> {
          buildSources = BuildSources{};
          it.first.package.manifest.dependencies
            .filter(t -> t.kind is Skargo.BuildDep())
            .each(dep -> {
              !buildSources = buildSources.union(
                collectBuildInfo.get(ctx, Dependency(dep)),
              );
            });
          !buildSources = buildSources.sources(
            build.srcs.map(src -> Path.join(path, src)),
          );
          // to do while libraries
          writer.set(
            Script(PackageId::create(package), build.name),
            buildSources,
          )
        });
    },
  );
  torun = commandsHdl.map(
    TargetedScript::keyType,
    SK.IntFile::type,
    context,
    dirName.sub("builds/torun"),
    (ctx, writer, key, it) ~> {
      time = it.first;
      builds.items(ctx).each(item ->
        writer.set(TargetedScript(item.i0, key.buildInfo), time)
      )
    },
  );
  tobuild = torun
    .map(
      Script::keyType,
      SK.IntFile::type,
      context,
      dirName.sub("builds/byname"),
      (_ctx, writer, key, it) ~> {
        writer.setArray(key.script, it.toArray())
      },
    )
    .map(
      Script::keyType,
      BuildSources::type,
      context,
      dirName.sub("builds/tobuild"),
      // ignore the change du to command
      (ctx, writer, key, _) ~> {
        writer.set(key, builds.get(ctx, key));
      },
    );
  built = tobuild.map(
    Script::keyType,
    BytesFile::type,
    context,
    dirName.sub("builds/built"),
    (ctx, writer, key, it) ~> {
      console = getConsole(ctx);
      package = allPackages.get(ctx, key.package).package;
      sources = it.first;
      // Create a dpendency on file changes
      sources.sources_.each(f -> _ = allFiles.maybeGet(ctx, SK.SID(f)));
      path = rootPathHdl.get(ctx, SKStore.UnitID::singleton).value;
      outfile = skc(
        skc_.process(),
        key.name,
        console,
        Skargo.Target(Skargo.BinTarget("main"), key.name, Array[]),
        package,
        sources,
        Options{
          output => Path.join(path, "target/.common"),
          profile => "dev",
          arch => Skargo.TargetArchHost(),
        },
        key.name,
      );
      content = mutable Vector[];
      file = IO.File::open(outfile.fromSome(), IO.OpenOptions{read => true});
      file.read_to_end(content) match {
      | Success _ ->
        file.close();
        writer.set(key, BytesFile(unsafe_chill_trust_me(content)))
      | Failure(e) -> throw e
      }
    },
  );
  toreallyrun = torun.map(
    TargetedScript::keyType,
    BytesFile::type,
    context,
    dirName.sub("builds/toreallyrun"),
    (ctx, writer, key, _) ~> {
      writer.set(key, built.get(ctx, key.script))
    },
  );
  runBuildScript = SKStore.LHandle::create(
    TargetedScript::keyType,
    BuildScriptOutput::type,
    context,
    dirName.sub("builds/runBuildScript"),
    (ctx, _self, key) ~> {
      binary = toreallyrun.get(ctx, key);
      console = getConsole(ctx);
      root = rootPathHdl.get(ctx, SKStore.UnitID::singleton).value;
      package = allPackages.get(ctx, key.script.package).package;
      path = package.root();
      binaryPath = Path.join(
        Path.join(Path.join(root, "target"), ".common"),
        key.script.name,
      );
      file = IO.File::open(
        binaryPath,
        IO.OpenOptions{write => true, create => true, truncate => true},
      );
      file.write_all(binary.bytes.bytes()) match {
      | Success _ -> file.close()
      | Failure(e) -> throw e
      };
      unit_name = `${package.name()} v${package.version()} [${
        key.script.name
      }] (${package.root()})`;
      console.status("Running", unit_name);
      targetDir = key.buildInfo.targetDir();
      output = Path.join(targetDir, key.script.name);
      bso = run_build_script(
        binaryPath,
        package,
        // todo good dir
        output,
        targetDir,
        key.buildInfo,
        console,
      );
      Array[BuildScriptOutput(toAbsolute(path, bso))]
    },
  );
  runned = toreallyrun.map(
    TargetedScript::keyType,
    BuildScriptOutput::type,
    context,
    dirName.sub("builds/bso"),
    (ctx, writer, key, _) ~> {
      writer.set(key, runBuildScript.get(ctx, key))
    },
  );
  runfiles = runned.map(
    SK.SID::keyType,
    SK.IntFile::type,
    context,
    dirName.sub("builds/files"),
    (ctx, writer, _key, it) ~> {
      // Get dependence to update all fill data
      _ = tomlHdl.get(ctx, SKStore.UnitID::singleton);
      bso = it.first.bso;
      bso.rerun_if_changed.each(f -> {
        mtile = FileSystem.getLastModificationTime(f);
        writer.set(SK.SID(f), SK.IntFile(mtile))
      })
    },
  );
  _ = runfiles.map(
    SK.SID::keyType,
    SK.IntFile::type,
    context,
    dirName.sub("builds/files/check"),
    (ctx, writer, key, it) ~> {
      console = getConsole(ctx);
      console.verbose(() -> {
        console.status("Modified", key.value)
      });
      writer.set(key, it.first)
    },
  );
  checkedrun = runned.map(
    TargetedScript::keyType,
    BuildScriptOutput::type,
    context,
    dirName.sub("builds/bso/checked"),
    (ctx, writer, key, it) ~> {
      bso = it.first.bso;
      package = allPackages.get(ctx, key.script.package).package;
      manifest = package.manifest;
      source = manifest.package_id.source_id;
      path = source.kind match {
      | Skargo.PathSource() -> source.url
      };
      // Add dependency to rerun_files
      bso.rerun_if_changed.each(f -> {
        file = Path.join(path, f);
        _ = runfiles.getArray(ctx, SK.SID(file))
      });
      writer.set(key, runBuildScript.get(ctx, key))
    },
  );
  buildartifacts = checkedrun.map(
    SK.SID::keyType,
    SK.IntFile::type,
    context,
    dirName.sub("builds/artifacts"),
    (ctx, writer, _key, it) ~> {
      // Get dependence to update all fill data
      _ = tomlHdl.get(ctx, SKStore.UnitID::singleton);
      bso = it.first.bso;
      bso.libraries.each(f -> {
        mtile = FileSystem.getLastModificationTime(f);
        writer.set(SK.SID(f), SK.IntFile(mtile))
      });
      bso.preambles.each(f -> {
        mtile = FileSystem.getLastModificationTime(f);
        writer.set(SK.SID(f), SK.IntFile(mtile))
      });
      bso.extra_sources.each(f -> {
        mtile = FileSystem.getLastModificationTime(f);
        writer.set(SK.SID(f), SK.IntFile(mtile))
      });
    },
  );
  _ = buildartifacts.map(
    SK.SID::keyType,
    SK.IntFile::type,
    context,
    dirName.sub("builds/artifacts/check"),
    (ctx, writer, key, it) ~> {
      console = getConsole(ctx);
      console.verbose(() -> {
        console.status("Modified", key.value)
      });
      writer.set(key, it.first)
    },
  );
  specificBuildInfo = buildBuildInfoCollector(
    context,
    dirName.sub("buildInfos/specific"),
    (ctx, dep) ~> {
      allPackageByName.getArray(ctx, SK.SID(dep.name)).filter(p ->
        dep.req.matches(p.package.manifest.package_id.version)
      )[0].package
    },
    (ctx, ts) ~> checkedrun.get(ctx, ts).bso,
  );
  sources = commandsHdl
    .map(
      BuildData::keyType,
      SK.IntFile::type,
      context,
      dirName.sub("commands/nottimed"),
      (_ctx, writer, key, _it) ~> {
        withTests = key match {
        | Check _ -> true
        | Build(target, _) -> target.kind is Skargo.TestTarget _
        };
        writer.set(BuildData(key.buildInfo, withTests), SK.IntFile(0))
      },
    )
    .map(
      BuildData::keyType,
      BuildSources::type,
      context,
      dirName.sub("builds/sources"),
      (ctx, writer, key, _it) ~> {
        package = pckHdl.get(ctx, SKStore.UnitID::singleton).package;
        packageId = PackageId::create(package);
        path = package.root();
        buildSources = BuildSources{};
        package.manifest.targets.each(target -> {
          if (
            target.kind is Skargo.LibTarget(Skargo.LibraryTypeSklib()) ||
            (key.withTests && target.kind is Skargo.TestTarget _)
          ) {
            !buildSources = buildSources.sources(
              target.srcs.map(src -> Path.join(path, src)),
            )
          } else if (target.kind is Skargo.CustomBuildTarget()) {
            bso = checkedrun.get(
              ctx,
              TargetedScript(Script(packageId, target.name), key.buildInfo),
            ).bso;
            !buildSources = buildSources.union(
              BuildSources::fromBuildScriptOutput(bso),
            )
          }
        });
        package.manifest.dependencies.each(dependency -> {
          if (dependency.kind is Skargo.BuildDep()) return void;
          !buildSources = buildSources.union(
            specificBuildInfo.get(
              ctx,
              Dependency(dependency, Some(key.buildInfo)),
            ),
          )
        });
        writer.set(key, buildSources)
      },
    );
  context.setPersistent(
    kEnvProperty,
    Environment(tomlHdl, pckHdl, commandsHdl, sources),
  )
}

fun run_build_script(
  binary: String,
  package: Skargo.Package,
  outdir: String,
  targetdir: String,
  buildInfo: BuildInfo,
  console: Skargo.Console,
  relocation_model: String = "static",
): Skargo.BuildScriptOutput {
  profile = buildInfo.profile;
  host = buildInfo.host;
  target = buildInfo.arch;

  create_dir(outdir);

  cmd = Skargo.ProcessBuilder::create{cmd => binary};

  cmd.cwd(package.root());

  cmd.env("SKARGO_MANIFEST_DIR", package.root());
  cmd.env("OUT_DIR", FileSystem.realpath(outdir));
  cmd.env("TARGET_DIR", FileSystem.realpath(targetdir));
  cmd.env("NAME", package.name());
  cmd.env("PROFILE", profile);
  cmd.env(
    "OPT_LEVEL",
    profile match {
    | "release" -> "3"
    | "debug" | "dev" -> "0"
    | p -> invariant_violation(`Unrecognized profile ${p}`)
    },
  );
  cmd.env("DEBUG", (profile != "release").toString());
  cmd.env(
    "VERBOSE",
    (console.verbosity >= Skargo.VerbosityVerbose()).toString(),
  );
  cmd.env("HOST", host.toString());
  cmd.env(
    "TARGET",
    target match {
    | Skargo.TargetArchHost() -> host.toString()
    | Skargo.TargetArchTriple(t) -> t.toString()
    },
  );
  cmd.env("RELOCATION_MODEL", relocation_model);
  p = run_cmd(cmd, console);
  Skargo.BuildScriptOutput::create(p.stdout);
}

fun run_cmd(
  cmd: readonly Skargo.ProcessBuilder,
  console: Skargo.Console,
): System.CompletedProcess {
  console.verbose(() -> {
    env = if (console.verbosity >= Skargo.VerbosityProlix()) {
      cmd.get_env().items().map(kv -> `${kv.i0}=${kv.i1}`).collect(Array)
    } else {
      Array[]
    };
    args = cmd.get_argv();
    console.status("Running", "`" + env.concat(args).join(" ") + "`")
  });

  p = if (console.verbosity >= Skargo.VerbosityProlix()) {
    cmd.run(print_raw, print_error_raw)
  } else {
    cmd.run()
  };

  if (!p.success()) {
    throw BuildScriptError(Skargo.subprocess_error_message(p));
  };
  p
}

fun skc(
  skc: mutable Skargo.ProcessBuilder,
  name: String,
  console: Skargo.Console,
  target: Skargo.Target,
  package: Skargo.Package,
  sources: BuildSources,
  options: Options,
  state: String,
): ?String {
  output = if (options.check) {
    skc.arg("--check");
    None()
  } else {
    outputs = outputs(options.output, package, target, options.arch);
    assert(outputs.size() == 1);
    skc.args(Array["-o", outputs[0].path]);
    Some(outputs[0].path)
  };
  bsmtime = sources.getLastModificationTime();
  unit_name = `${package.name()} v${package.version()} [${name}] (${package.root()})`;
  output match {
  | Some(
    o,
  ) if (
    FileSystem.exists(o) &&
    FileSystem.getLastModificationTime(o) >= bsmtime
  ) ->
    console.status("Fresh", unit_name);
    return output
  | _ -> void
  };
  console.status(if (name == "check") "Check" else "Compiling", unit_name);

  create_dir(options.output);

  skc.cwd(package.root());

  options.arch match {
  | Skargo.TargetArchHost() -> void
  | Skargo.TargetArchTriple(t) -> skc.arg(`--target=${t}`)
  };

  // TODO: Support this in a more generic way.
  if (options.noStd) {
    skc.arg("--no-std")
  };

  if (!sources.link_args_.isEmpty()) {
    skc.args(Array["--link-args", sources.link_args_.toArray().join(" ")])
  };

  libraries = Array[];
  sources.libraries_.each(l -> !libraries = libraries.concat(l.reversed()));

  skc.args(libraries);
  skc.args(sources.sources_.toArray());

  state_db_path = Path.join(options.output, `${state}_state.db`);
  skc.args(
    Array[
      if (FileSystem.exists(state_db_path)) {
        "--data"
      } else {
        "--init"
      },
      state_db_path,
    ],
  );
  target.kind match {
  | Skargo.LibTarget(Skargo.LibraryTypeSklib()) ->
    skc.arg(`--sklib-name=${package.name()}`)
  | Skargo.LibTarget(Skargo.LibraryTypeCdylib()) -> skc.arg("--emit=cdylib")
  | Skargo.BinTarget(e)
  | Skargo.TestTarget(e) ->
    skc.args(Array["--export-function-as", `${e}=skip_main`])
  | Skargo.CustomBuildTarget() -> void
  };

  // TODO: Proper Profile class.
  options.profile match {
  | "release" -> skc.arg("-O2")
  | "debug" | "dev" -> skc.arg("-O0")
  | _ -> invariant_violation("unreachable")
  };

  // Enviroment

  skc.env("SKARGO_MANIFEST_DIR", package.root());
  skc.env("SKARGO_PKG_NAME", package.name());
  skc.env("SKARGO_PKG_VERSION", package.version().toString());
  if (!sources.preambles_.isEmpty()) {
    skc.env(
      "SKC_PREAMBLE",
      sources.preambles_.toArray().join(Path.listSeparator),
    )
  };
  sources.env_.each(env -> skc.env(env.i0, env.i1));
  output.each(o ->
    if (FileSystem.exists(o)) {
      _ = system(`rm ${o}`)
    }
  );
  _ = run_cmd(skc, console);
  output
}

fun initCtx(dirName: SK.DirName): SK.Context {
  context = SK.Context::mcreate{};
  init(context, dirName);
  context.clone();
}

fun suffix_for_lib(arch: Skargo.TargetArch): String {
  arch match {
  | Skargo.TargetArchTriple(
    Skargo.TargetTriple("wasm32", None(), None(), None()),
  ) ->
    "wasm"
  | _ -> "so"
  }
}

fun suffix_for_binary(arch: Skargo.TargetArch, is_test: Bool): String {
  arch match {
  | Skargo.TargetArchTriple(t) if (t.isWasm32() && is_test) -> ".wasm"
  | _ -> ""
  }
}

fun binary_file_for(
  output: String,
  target: Skargo.Target,
  arch: Skargo.TargetArch,
): String {
  assert(target.is_bin() || target.is_test());
  name = target.name;
  suffix = suffix_for_binary(arch, target.is_test());
  Path.join(output, `${name}${suffix}`)
}

fun lib_file_for(
  output: String,
  package: Skargo.Package,
  target: Skargo.Target,
): String {
  suffix = target.kind match {
  | Skargo.LibTarget(Skargo.LibraryTypeSklib _) -> "sklib"
  | Skargo.LibTarget(Skargo.LibraryTypeCdylib _) -> "so"
  | _ -> invariant_violation("Invalid target kind for lib_file_for()")
  };
  name = package.name();
  Path.join(output, `lib${name}.${suffix}`)
}

fun outputs(
  output: String,
  package: Skargo.Package,
  target: Skargo.Target,
  arch: Skargo.TargetArch,
): Array<Skargo.OutputFile> {
  res = mutable Vector[];
  target.kind match {
  | Skargo.LibTarget _ ->
    file = Skargo.OutputFile(
      lib_file_for(output, package, target),
      None(),
      None(),
    );
    res.push(file)
  | Skargo.BinTarget _
  | Skargo.TestTarget _ ->
    file = Skargo.OutputFile(
      binary_file_for(output, target, arch),
      None(),
      None(),
    );
    res.push(file)
  | Skargo.CustomBuildTarget _ ->
    base_path = Path.join(output, "custom_builds");
    res.push(
      Skargo.OutputFile(Path.join(base_path, target.name), None(), None()),
    )
  };
  res.collect(Array)
}

fun create_dir(path: String): void {
  _ = system(`mkdir -p ${path}`)
}

private fun get_host_target(): Skargo.TargetTriple {
  p = System.subprocess(Array["llvm-config", "--host-target"]).fromSuccess();
  if (!p.success()) {
    throw HostTargetError(Skargo.subprocess_error_message(p));
  };
  Skargo.TargetTriple::fromString(p.stdout.trim())
}

private fun toAbsolute(
  base: String,
  bso: Skargo.BuildScriptOutput,
): Skargo.BuildScriptOutput {
  !bso.rerun_if_changed = bso.rerun_if_changed.map(f -> Path.join(base, f));
  !bso.preambles = bso.preambles.map(f -> Path.join(base, f));
  !bso.extra_sources = bso.extra_sources.map(f -> Path.join(base, f));
  bso
}

module end;
