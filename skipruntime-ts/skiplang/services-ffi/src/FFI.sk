module alias SR = SkipRuntime;

module SkipRuntimeFFI;

@cpp_export("SkipRuntime_instantiateResource")
fun instantiateResource(
  identifier: String,
  resource: String,
  params: String,
  executor: SR.Executor,
): ?String {
  ServiceInstance.instantiateResource(
    identifier,
    resource,
    params,
    executor,
  ) match {
  | Failure(ex) -> Some(ex.getMessage())
  | _ -> None()
  }
}

@cpp_export("SkipRuntime_closeResourceInstance")
fun closeResourceInstance(identifier: String): ?String {
  ServiceInstance.closeResourceInstance(identifier) match {
  | Failure(ex) -> Some(ex.getMessage())
  | _ -> None()
  }
}

/************  Notifier ****************/

class NotifierException(message: String) extends .Exception {
  fun getMessage(): String {
    this.message
  }
}

@export("SkipRuntime_checkNotifierException")
fun throwNotifierException(message: ?String): void {
  message match {
  | Some(msg) if (!msg.isEmpty()) -> throw NotifierException(msg)
  | _ -> void
  }
}

@cpp_extern("SkipRuntime_Notifier__notify")
@debug
native fun notifyOfNotifier(
  notifier: UInt32,
  values: String,
  watermark: String,
  updates: Bool,
): void;

@cpp_extern("SkipRuntime_Notifier__close")
@debug
native fun closeOfNotifier(notifier: UInt32): void;

@cpp_extern("SkipRuntime_deleteNotifier")
@debug
native fun deleteNotifier(notifier: UInt32): void;

@export("SkipRuntime_createNotifier")
fun createNotifier(notifier: UInt32): ExternNotifier {
  ExternNotifier(SKStore.ExternalPointer::create(notifier, deleteNotifier))
}

class ExternNotifier(
  eptr: SKStore.ExternalPointer,
) extends ServiceInstance.Notifier {
  fun notify(values: String, watermark: String, updates: Bool): void {
    notifyOfNotifier(this.eptr.value, values, watermark, updates)
  }

  fun close(): void {
    closeOfNotifier(this.eptr.value)
  }
}

/************  Executor ****************/

@cpp_extern("SkipRuntime_Executor__resolve")
@debug
native fun resolveOfExecutor(executor: UInt32): void;

@cpp_extern("SkipRuntime_Executor__reject")
@debug
native fun rejectOfExecutor(executor: UInt32, message: String): void;

@cpp_extern("SkipRuntime_deleteExecutor")
@debug
native fun deleteExecutor(mapper: UInt32): void;

@export("SkipRuntime_createExecutor")
fun createExecutor(executor: UInt32): ExternExecutor {
  ExternExecutor(SKStore.ExternalPointer::create(executor, deleteExecutor))
}

class ExternExecutor(eptr: SKStore.ExternalPointer) extends SR.Executor {
  fun resolve(): void {
    resolveOfExecutor(this.eptr.value)
  }

  fun reject(exc: .Exception): void {
    rejectOfExecutor(this.eptr.value, exc.getMessage())
  }
}

/************  Snapshot ****************/

value class SnapshotResult(is_ok: Bool, value: String)

// TODO use a printer instead of returning the result

@export("SkipRuntime_resourceSnapshot")
fun resourceSnapshot(resource: String, params: String): SnapshotResult {
  ServiceInstance.resourceSnapshot(resource, params) match {
  | Failure(ex) -> SnapshotResult(false, ex.getMessage())
  | Success(value) -> SnapshotResult(true, value)
  }
}

@export("SkipRuntime_resourceSnapshotLookup")
fun resourceSnapshotLookup(
  resource: String,
  params: String,
  key: String,
): SnapshotResult {
  ServiceInstance.resourceSnapshotLookup(resource, params, key) match {
  | Failure(ex) -> SnapshotResult(false, ex.getMessage())
  | Success(value) -> SnapshotResult(true, value)
  }
}

value class SubscribeResult(id: Int, error: ?String)

@export("SkipRuntime_subscribe")
fun subscribe(
  identifier: String,
  notifier: ServiceInstance.Notifier,
  watermark: ?String,
  session: UInt32,
): SubscribeResult {
  ServiceInstance.subscribe(
    identifier,
    notifier,
    watermark,
    Some(session.toInt()),
  ) match {
  | Failure(ex) -> SubscribeResult(0, Some(ex.getMessage()))
  | Success(id) -> SubscribeResult(id, None())
  };
}

@export("SkipRuntime_unsubscribe")
fun unsubscribe(identifier: Int): ?String {
  ServiceInstance.unsubscribe(identifier) match {
  | Failure(ex) -> Some(ex.getMessage())
  | _ -> None()
  }
}

@export("SkipRuntime_update")
fun update(input: String, values: String, executor: ExternExecutor): ?String {
  ServiceInstance.update(input, values, executor) match {
  | Failure(ex) -> Some(ex.getMessage())
  | _ -> None()
  }
}

@export("SkipRuntime_initService")
fun initService(service: SR.Service, executor: ExternExecutor): ?String {
  ServiceInstance.init(service, executor) match {
  | Failure(ex) -> Some(ex.getMessage())
  | _ -> None()
  }
}

module end;
