module alias SRS = SRSerialization;

module SKJSON;

fun formatter(
  write: .String -> void,
  isPretty: .Bool = false,
): mutable JSON.Formatter {
  if (isPretty) {
    mutable JSON.PrettyFormatter(write)
  } else {
    mutable JSON.CompactFormatter(write)
  };
}

fun writer(write: .String -> void, isPretty: .Bool = false): mutable Writer {
  mutable Writer(formatter(write, isPretty));
}

fun streamSerialize<T: SRS.Serializable>(
  value: T,
  write: .String -> void,
  isPretty: .Bool = false,
): Result<void, Serialization.SerializationError> {
  try {
    writer = writer(write, isPretty);
    value.serialize(writer);
    writer.result();
    Success(void)
  } catch {
  | exn @ Serialization.SerializationError _ -> Failure(exn)
  | e -> throw e
  }
}

fun serialize<T: SRS.Serializable>(
  value: T,
  isPretty: .Bool = false,
): Result<.String, Serialization.SerializationError> {
  vec = mutable Vector[];
  result = streamSerialize(value, vec.push, isPretty);
  result match {
  | Success _ -> Success(vec.join(""))
  | Failure(exn) -> Failure(exn)
  }
}

private mutable base class DefaultWriter(
  jsonFormatter: mutable JSON.Formatter,
) extends SRS.DefaultWriter {
  type T_result = void;

  overridable mutable fun result(): this::T_result {
    void
  }

  overridable mutable fun writeBool(value: .Bool): void {
    this.jsonFormatter.writeRaw(value.toString())
  }

  overridable mutable fun writeFloat(value: Float): void {
    this.jsonFormatter.writeRaw(value.toString())
  }

  overridable mutable fun writeInt(value: Int): void {
    this.jsonFormatter.writeRaw(value.toString())
  }

  overridable mutable fun writeString(value: .String): void {
    JSON.writeStringValue(this.jsonFormatter.writeRaw, value)
  }

  overridable mutable fun writeSequence<T: SRS.Serializable>(
    _sizeHint: SRS.SizeHint = None(),
  ): mutable SRS.SequenceWriter<T> {
    mutable SequenceWriter(this.jsonFormatter)
  }

  overridable mutable fun writeTuple(_size: SRS.Size): mutable SRS.TupleWriter {
    mutable TupleWriter(this.jsonFormatter)
  }
  overridable mutable fun writeKeyedSequence<
    K: SRS.Serializable,
    V: SRS.Serializable,
  >(
    _sizeHint: SRS.SizeHint = None(),
  ): mutable SRS.KeyedSequenceWriter<K, V> {
    mutable KeyedSequenceWriter(this.jsonFormatter)
  }

  overridable mutable fun writeRecord(
    _fieldNames: .Array<.String>,
  ): mutable SRS.RecordWriter {
    mutable RecordWriter(this.jsonFormatter)
  }

  overridable mutable fun writeVoid(): void {
    throw Serialization.NotImplementedError(`writeVoid()`)
  }

  overridable mutable fun writeOption<T: SRS.Serializable>(value: ?T): void {
    value match {
    | None() -> this.jsonFormatter.writeRaw("null")
    | Some(x) ->
      writer = mutable OptionWriter(this.jsonFormatter);
      x.serialize(writer)
    }
  }

  overridable mutable fun writeType(name: .String): void {
    JSON.writeStringValue(this.jsonFormatter.writeRaw, name)
  }

  overridable mutable fun writeVariant<T: SRS.Serializable>(
    childName: .String,
    value: T,
  ): void {
    record = mutable RecordWriter(this.jsonFormatter);
    record.writeItem(childName, value);
    record.end()
  }
}

private mutable class Writer() extends DefaultWriter {}

// we need the begun state in order to prevent writing of ', '
// after every element in sequence.
// Otherwise, we would output JSON such as '[1, 2, 3, ]'
private mutable base class ValueWriter() {
  mutable fun writeValueBase<T: SRS.Serializable>(
    jsonFormatter: mutable JSON.Formatter,
    value: T,
    begun: .Bool,
  ): void {
    if (!begun) {
      jsonFormatter.writeSquareOpen();
    } else {
      jsonFormatter.writeComma();
    };
    writer = mutable Writer(jsonFormatter);
    value.serialize(writer)
  }
  mutable fun endBase(
    jsonFormatter: mutable JSON.Formatter,
    begun: .Bool,
  ): void {
    if (!begun) {
      jsonFormatter.writeRaw("[]")
    } else {
      jsonFormatter.writeSquareClose()
    }
  }
}

private mutable class SequenceWriter<T: SRS.Serializable>(
  jsonFormatter: mutable JSON.Formatter,
  mutable begun: .Bool = false,
) extends SRS.SequenceWriter<T>, ValueWriter {
  mutable fun writeValue(value: T): void {
    this.writeValueBase(this.jsonFormatter, value, this.begun);
    this.!begun = true
  }
  mutable fun end(): void {
    this.endBase(this.jsonFormatter, this.begun);
    this.!begun = true
  }
}

private mutable class TupleWriter(
  jsonFormatter: mutable JSON.Formatter,
  mutable begun: .Bool = false,
) extends SRS.TupleWriter, ValueWriter {
  mutable fun writeValue<T: SRS.Serializable>(value: T): void {
    this.writeValueBase(this.jsonFormatter, value, this.begun);
    this.!begun = true
  }
  mutable fun end(): void {
    this.endBase(this.jsonFormatter, this.begun);
    this.!begun = true
  }
}

private mutable base class ItemWriter() {
  mutable fun writeItemBase<K: SRS.Serializable, V: SRS.Serializable>(
    jsonFormatter: mutable JSON.Formatter,
    key: K,
    value: V,
    begun: .Bool,
  ): void {
    if (!begun) {
      jsonFormatter.writeCurlyOpen();
    } else {
      jsonFormatter.writeComma();
    };
    keyWriter = mutable StringWriter(jsonFormatter);
    key.serialize(keyWriter);
    jsonFormatter.writeColon();
    valueWriter = mutable Writer(jsonFormatter);
    value.serialize(valueWriter)
  }

  mutable fun endBase(
    jsonFormatter: mutable JSON.Formatter,
    begun: .Bool,
  ): void {
    if (!begun) {
      jsonFormatter.writeRaw("{}");
      !begun = true
    } else {
      jsonFormatter.writeCurlyClose()
    }
  }
}

private mutable class KeyedSequenceWriter<
  K: SRS.Serializable,
  V: SRS.Serializable,
>(
  jsonFormatter: mutable JSON.Formatter,
  mutable begun: .Bool = false,
) extends SRS.KeyedSequenceWriter<K, V>, ItemWriter {
  mutable fun writeItem(key: K, value: V): void {
    this.writeItemBase(this.jsonFormatter, key, value, this.begun);
    this.!begun = true
  }
  mutable fun end(): void {
    this.endBase(this.jsonFormatter, this.begun);
    this.!begun = true
  }
}

private mutable class RecordWriter(
  jsonFormatter: mutable JSON.Formatter,
  mutable begun: .Bool = false,
) extends SRS.RecordWriter, ItemWriter {
  mutable fun writeItem<T: SRS.Serializable>(
    fieldName: .String,
    value: T,
  ): void {
    this.writeItemBase(this.jsonFormatter, fieldName, value, this.begun);
    this.!begun = true
  }
  mutable fun end(): void {
    this.endBase(this.jsonFormatter, this.begun);
    this.!begun = true
  }
}

private mutable class StringWriter(
  jsonFormatter: mutable JSON.Formatter,
) extends SRS.DefaultWriter {
  type T_result = void;

  mutable fun result(): this::T_result {
    void
  }

  mutable fun writeString(value: .String): void {
    JSON.writeStringValue(this.jsonFormatter.writeRaw, value)
  }
}

private mutable class OptionWriter() extends DefaultWriter {
  mutable fun writeOption<T: SRS.Serializable>(_value: ?T): void {
    throw Serialization.NotSupportedError(`writeOption()`)
  }
}

private mutable base class DefaultReader(
  iter: mutable Lexer.LexingPosition,
) extends SRS.DefaultReader {
  //
  overridable mutable fun readBool(): .Bool {
    JSON.eatWhitespace(this.iter);
    c = this.iter.peek();
    c match {
    | 't' ->
      JSON.eatString(this.iter, "true");
      true
    | 'f' ->
      JSON.eatString(this.iter, "false");
      false
    | _ ->
      JSON.reportInvalidJSON(
        this.iter,
        `Invalid JSON start character '${c}' for Bool.`,
      )
    }
  }

  overridable mutable fun readFloat(): Float {
    JSON.eatWhitespace(this.iter);
    start = this.iter.clone();
    JSON.skipSignOpt(this.iter);
    JSON.skipDigits(this.iter);
    _ = JSON.skipFractionOpt(this.iter);
    _ = JSON.skipExponentOpt(this.iter);
    value = start.getText(this.iter);
    if (value == "-0") {
      -0.0
    } else {
      value.toFloat()
    }
  }

  overridable mutable fun readInt(): Int {
    JSON.eatWhitespace(this.iter);
    start = this.iter.clone();
    JSON.skipSignOpt(this.iter);
    JSON.skipDigits(this.iter);
    value = start.getText(this.iter);
    if (value == "-0") {
      0
    } else {
      value.toInt()
    }
  }

  overridable mutable fun readString(): .String {
    JSON.eatWhitespace(this.iter);
    JSON.decodeString(this.iter)
  }

  overridable mutable fun readSequence<
    T: SRS.Serializable,
  >(): mutable SRS.SequenceReader<T> {
    JSON.eatWhitespace(this.iter);
    JSON.eat(this.iter, '[');
    mutable SequenceReader(this.iter)
  }

  overridable mutable fun readTuple(_size: SRS.Size): mutable SRS.TupleReader {
    JSON.eatWhitespace(this.iter);
    JSON.eat(this.iter, '[');
    mutable TupleReader(this.iter);
  }

  overridable mutable fun readKeyedSequence<
    K: SRS.Serializable,
    V: SRS.Serializable,
  >(): mutable SRS.KeyedSequenceReader<K, V> {
    JSON.eatWhitespace(this.iter);
    JSON.eat(this.iter, '{');
    mutable KeyedSequenceReader(this.iter)
  }

  overridable mutable fun readRecord(
    _fieldNames: .Array<.String>,
  ): mutable SRS.RecordReader {
    JSON.eatWhitespace(this.iter);
    JSON.eat(this.iter, '{');
    mutable RecordReader(this.iter)
  }

  overridable mutable fun readOption<T: SRS.Serializable>(): ?T {
    JSON.eatWhitespace(this.iter);
    this.iter.peek() match {
    | 'n' ->
      JSON.eatString(this.iter, "null");
      None()
    | _ -> Some(invariant_violation("TODO"))
    // Some(mutable OptionReader(this.iter))
    }
  }

  overridable mutable fun readType(): .String {
    JSON.eatWhitespace(this.iter);
    JSON.decodeString(this.iter)
  }

  overridable mutable fun readVariant(): (.String, mutable Reader, () -> void) {
    JSON.eatWhitespace(this.iter);
    JSON.eat(this.iter, '{');
    record = mutable RecordReader(this.iter);
    key = record.readKey();
    key match {
    | Some(className) ->
      value = mutable Reader(this.iter);
      JSON.eatWhitespace(this.iter);
      (className, value, record.end)
    | None() -> throw Serialization.VariantMissingError()
    }
  }
}

private mutable class Reader() extends DefaultReader {}

private mutable base class ValueReader() {
  //
  mutable fun readValueBase<T: SRS.Serializable>(
    iter: mutable Lexer.LexingPosition,
  ): ?T {
    JSON.eatWhitespace(iter);
    if (iter.peek() == ']') {
      None()
    } else {
      // serializer.deserialize(mutable Reader(iter))
      v = Some(invariant_violation("TODO"));
      JSON.eatWhitespace(iter);
      iter.peek() match {
      | ',' ->
        iter.advance();
        JSON.eatWhitespace(iter)
      | ']' -> void
      | c ->
        JSON.reportInvalidJSON(
          iter,
          `Unexpected character ''${JSON.charToString(
            c,
          )} in JSON .Array. Expected ',' or ']'.`,
        )
      };
      JSON.eatWhitespace(iter);
      v
    }
  }

  mutable fun endBase(iter: mutable Lexer.LexingPosition): void {
    JSON.eatWhitespace(iter);
    JSON.eat(iter, ']')
  }
}

private mutable class SequenceReader<T: SRS.Serializable>(
  iter: mutable Lexer.LexingPosition,
) extends SRS.SequenceReader<T>, ValueReader {
  //
  mutable fun sizeHint(): Serialization.SizeHint {
    None()
  }

  mutable fun readValue(): ?T {
    this.readValueBase(this.iter)
  }

  mutable fun end(): void {
    this.endBase(this.iter)
  }
}

private mutable class TupleReader(
  iter: mutable Lexer.LexingPosition,
) extends SRS.TupleReader, ValueReader {
  //
  mutable fun readValue<T: SRS.Serializable>(): T {
    this.readValueBase(this.iter) match {
    | Some(val) -> val
    | None() -> throw Serialization.TupleSizeOutOfBoundsError()
    }
  }

  mutable fun end(): void {
    this.endBase(this.iter)
  }
}

private mutable base class ItemReader() {
  //
  mutable fun readKeyBase<T: SRS.Serializable>(
    iter: mutable Lexer.LexingPosition,
  ): ?T {
    JSON.eatWhitespace(iter);
    if (iter.peek() == '}') {
      None()
    } else {
      // String::deserialize(mutable StringReader(iter))
      key = invariant_violation("TODO");
      JSON.eatWhitespace(iter);
      JSON.eat(iter, ':');
      JSON.eatWhitespace(iter);
      Some(key)
    }
  }

  mutable fun readValueBase<T: SRS.Serializable>(
    iter: mutable Lexer.LexingPosition,
  ): T {
    // serializer.deserialize(mutable Reader(iter));
    value = invariant_violation("TODO");
    JSON.eatWhitespace(iter);
    iter.peek() match {
    | ',' ->
      JSON.eat(iter, ',');
      JSON.eatWhitespace(iter)
    | '}' -> void
    | c ->
      JSON.reportInvalidJSON(
        iter,
        `Unexpected character '${JSON.charToString(
          c,
        )}' in JSON .Array. Expected ',' or ']'.`,
      )
    };
    value
  }

  mutable fun endBase(iter: mutable Lexer.LexingPosition): void {
    JSON.eatWhitespace(iter);
    JSON.eat(iter, '}')
  }
}

private mutable class KeyedSequenceReader<
  K: SRS.Serializable,
  V: SRS.Serializable,
>(
  iter: mutable Lexer.LexingPosition,
) extends SRS.KeyedSequenceReader<K, V>, ItemReader {
  mutable fun sizeHint(): SRS.SizeHint {
    None()
  }

  mutable fun readItem(): ?(K, V) {
    keyOption = this.readKeyBase(this.iter);
    keyOption match {
    | Some(key) -> Some((key, this.readValueBase(this.iter)))
    | None() -> None()
    }
  }

  mutable fun end(): void {
    this.endBase(this.iter);
  }
}

private mutable class RecordReader(
  iter: mutable Lexer.LexingPosition,
) extends SRS.RecordReader, ItemReader {
  //
  mutable fun readKey(): ?.String {
    Some(String::deserialize(mutable StringReader(this.iter)))
  }

  mutable fun readValue<T: SRS.Serializable>(): T {
    this.readValueBase(this.iter)
  }

  mutable fun end(): void {
    this.endBase(this.iter)
  }
}

private mutable class StringReader(
  iter: mutable Lexer.LexingPosition,
) extends SRS.DefaultReader {
  mutable fun readString(): .String {
    JSON.eatWhitespace(this.iter);
    JSON.decodeString(this.iter)
  }
}

private mutable class OptionReader() extends DefaultReader {
  mutable fun readOption<T: SRS.Serializable>(): ?T {
    throw Serialization.NotSupportedError(`readOption()`)
  }
}

module end;
