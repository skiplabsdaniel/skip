module SkipRuntime;

const kSessionDir: SKStore.DirName = SKStore.DirName::make("/sk_prv/sessions/");
const kTokenDir: SKStore.DirName = SKStore.DirName::make("/sk_prv/tokens/");
const kGraphDir: SKStore.DirName = SKStore.DirName::make("/sk_prv/graph/");
const kResourceSessionDir: SKStore.DirName = SKStore.DirName::make(
  "/sk_prv/resources/sessions/",
);
const kResourceAvailablesDir: SKStore.DirName = kResourceSessionDir.build(
  "availables",
);
const kResourceStatusDir: SKStore.DirName = kResourceSessionDir.build("status");

const kResourceGraphDir: SKStore.DirName = SKStore.DirName::make(
  "/sk_prv/resources/graph/",
);
const kResourceCollectionsDir: SKStore.DirName = SKStore.DirName::make(
  "/sk_prv/resources/collections/",
);
const kResourceGarbageDir: SKStore.DirName = SKStore.DirName::make(
  "/sk_prv/resources/garbage/",
);

const kResourceInstance2SubIdDir: SKStore.DirName = SKStore.DirName::make(
  "/sk_prv/resources/instance2subid/",
);

const kSessionHdl: SKStore.EHandle<
  SKStore.UnitID,
  ServiceDefinition,
> = SKStore.EHandle(
  SKStore.UnitID::keyType,
  ServiceDefinition::type,
  kSessionDir,
);

const kGraphHdl: SKStore.EHandle<SKStore.SID, ServiceFile> = SKStore.EHandle(
  SKStore.SID::keyType,
  ServiceFile::type,
  kGraphDir,
);

fun resourceArrow(def: ResourceDef): SKStore.ArrowKey {
  SKStore.TArrowKey::create{
    parentName => kResourceStatusDir,
    childName => kResourceCollectionsDir,
    key => def,
  }
}

fun serviceArrow(runId: SKStore.SID): SKStore.ArrowKey {
  SKStore.TArrowKey::create{
    parentName => kSessionDir.build("inputs"),
    childName => kGraphDir,
    key => runId,
  }
}

class JSONID(json: SKJSON.CJSON) extends SKStore.Key {
  //
  fun toString(): String {
    this.json.prettyPrint()
  }
}

class JSONFile(json: SKJSON.CJSON) extends SKStore.File

fun accReducer<V1: SKStore.File, V2: SKStore.File>(
  reducer: Reducer<V1, V2>,
): SKStore.EReducer<V1, V2> {
  SKStore.EReducer{
    type => reducer.getType(),
    canReset => true,
    init => iter ~> {
      acc = reducer.initial;
      for (x in iter) {
        !acc = reducer.add(acc, x)
      };
      Array[acc]
    },
    update => (state, old, new) ~> {
      acc = state[0];
      for (x in old) {
        reducer.remove(acc, x) match {
        | Some(v) -> !acc = v
        | _ -> return None()
        }
      };
      for (x in new) {
        !acc = reducer.add(acc, x)
      };
      Some(Array[acc])
    },
  }
}

fun identityMap<K: SKStore.Key, V: SKStore.File>(
  _context: mutable SKStore.Context,
  writer: mutable SKStore.TWriter<K, V>,
  key: K,
  it: mutable SKStore.NonEmptyIterator<V>,
): void {
  writer.setArray(key, Array::createFromIterator(it.values())); // TODO: use it.toArray()
}

fun noFilter<K: SKStore.Key, V: SKStore.File>(
  _context: readonly SKStore.Context,
  _key: K,
  _value: V,
): Bool {
  true
}

fun countElementAsOne<V: SKStore.File>(_value: SKStore.File): Int {
  1
}

fun removeElementAsOne<V: SKStore.File>(_value: V, _toRemove: Int): V {
  invariant_violation("removeElementAsOne called on singleton value");
}

fun toMapperName(
  context: mutable SKStore.Context,
  kind: String,
  id: String = "",
): SKStore.DirName {
  path = context.currentArrow() match {
  | Some(arrow) ->
    tArrow = SKStore.castKeyArrow<SKStore.Key>(arrow);
    tArrow.key match {
    | ResourceDef(
      name,
      params,
    ) if (arrow.childName == kResourceCollectionsDir) ->
      SKStore.DirName::make(
        `/sk/resource_mappers/${name}/${base64(params.prettyPrint())}/${kind}/`,
      )
    | SKStore.SID _ if (arrow.childName == kGraphDir) ->
      SKStore.DirName::make(`/sk/mappers/${kind}/`)
    | _ ->
      b64 = base64(arrow.getKeyString());
      arrow.parentName.build(`mappers/${b64}/${kind}`)
    }
  | _ -> invariant_violation("Must be called into mapper")
  };
  if (!id.isEmpty()) path.build(id) else path
}

fun base64<T: Show>(toEncode: T): String {
  b64 = Base64.encodeString(toEncode.toString(), true);
  encoded = `b64_${b64}`;
  encoded.replace("=", ".")
}

fun unbase64<T>(toDecode: String, conv: String ~> T): T {
  invariant(toDecode.startsWith("b64_"));
  encoded = toDecode.substring(toDecode.getIter().forward(4)).replace(".", "=");
  decoded = Base64.decodeString(encoded);
  conv(decoded)
}

fun toResourceId(
  resource: String,
  params: SKJSON.CJSON,
  sep: String = "_",
): String {
  `${resource}${sep}${base64(params.prettyPrint())}`
}

fun toSuppliedResourceId(
  supplier: String,
  resource: String,
  params: SKJSON.CJSON,
  sep: String = "_",
): String {
  `${supplier}${sep}${toResourceId(resource, params, sep)}`;
}

fun collectionForName(name: String): Collection {
  Collection::forName(name)
}

fun lazyForName(name: String): LazyCollection {
  LazyCollection::forName(name)
}

fun collectionsByName(collections: Map<String, Collection>): SKJSON.CJObject {
  fields = mutable Vector[];
  collections.each((k, c) -> fields.push((k, SKJSON.CJString(c.getId()))));
  SKJSON.CJObject(SKJSON.CJFields::create(fields.toArray(), x -> x));
}

module end;

module SKStore;

// Case sensitive utils for DirName

extension class DirName {
  static fun make(dirName: String): DirName {
    static::validateDirName(dirName);
    static::create_no_validate(dirName)
  }

  fun build(str: String, prv: Bool = false): this {
    validator = mutable SKStoreImpl.NameValidator(str, str.chars(), 0);
    validator.mustBeKey();
    name = if (prv && !this.dirName.startsWith("/sk_prv/")) {
      `/sk_prv${this.dirName}${str}/`
    } else {
      `${this.dirName}${str}/`
    };
    static::create_no_validate(name)
  }
}

module end;

module SKStore;

fun instanceOfResourceDefKA<K: Orderable & Show>(arrow: ArrowKey): Bool {
  Unsafe.instanceOf(arrow, TArrowKey<SkipRuntime.ResourceDef>)
}

fun instanceOfKeyArrow<K: Orderable & Show>(arrow: ArrowKey): Bool {
  Unsafe.instanceOf(arrow, TArrowKey<K>)
}

fun castKeyArrow<K: Orderable & Show>(arrow: ArrowKey): TArrowKey<K> {
  Unsafe.cast(arrow, TArrowKey<K>)
}

extension class EHandle {
  fun unsafeItems(
    context: readonly Context,
  ): mutable Iterator<(K, mutable Iterator<V>)> {
    dir = context.unsafeGetEagerDir(this.dirName);
    dir.unsafeGetFileIter().map(kv ->
      (this.keyType(kv.i0), kv.i1.map(this.type))
    )
  }
}

module end;
