module SkipRuntime;

const kSessionDir: SKStore.DirName = SKStore.DirName::create(
  "/sk_prv/sessions/",
);
const kTokenDir: SKStore.DirName = SKStore.DirName::create("/sk_prv/tokens/");
const kGraphDir: SKStore.DirName = SKStore.DirName::create("/sk_prv/graph/");
const kResourceSessionDir: SKStore.DirName = SKStore.DirName::create(
  "/sk_prv/resources/sessions/",
);
const kResourceAvailablesDir: SKStore.DirName = kResourceSessionDir.sub(
  "availables",
);

const kResourceGraphDir: SKStore.DirName = SKStore.DirName::create(
  "/sk_prv/resources/graph/",
);
const kResourceCollectionsDir: SKStore.DirName = SKStore.DirName::create(
  "/sk_prv/resources/collections/",
);
const kResourceGarbageDir: SKStore.DirName = SKStore.DirName::create(
  "/sk_prv/resources/garbage/",
);

const kResourceInstance2SubIdDir: SKStore.DirName = SKStore.DirName::create(
  "/sk_prv/resources/instance2subid/",
);

const kSubscriptionsKey: String = "externals.subscriptions";

class SubscriptionsFile(value: Array<Waitable>) extends SKStore.File

class JSONID(json: SKJSON.CJSON) extends SKStore.Key {
  //
  fun toString(): String {
    this.json.prettyPrint()
  }
}

class JSONFile(json: SKJSON.CJSON) extends SKStore.File

fun noFilter<K: SKStore.Key, V: SKStore.File>(
  _context: readonly SKStore.Context,
  _key: K,
  _value: V,
): Bool {
  true
}

fun countElementAsOne<V: SKStore.File>(_value: SKStore.File): Int {
  1
}

fun removeElementAsOne<V: SKStore.File>(_value: V, _toRemove: Int): V {
  invariant_violation("removeElementAsOne called on singleton value");
}

fun subDirName(
  context: readonly SKStore.Context,
  name: String,
  parent: ?SKStore.DirName,
): SKStore.DirName {
  p = parent.map(v -> `${xxHash(v)}/`).default("");
  path = context.currentArrow() match {
  | Some(arrow) -> `/${xxHash(arrow)}/${p}${name}/`
  | None() -> `/sk/${p}${name}/`
  };
  SKStore.DirName::create(path)
}

fun xxHash<T: Show>(toEncode: T): String {
  `xx_${XXHash64.xxHash64String(toEncode.toString())}`
}

fun toResourceId(resource: String, params: SKJSON.CJSON): String {
  `${resource}_${xxHash(params.prettyPrint())}`
}

fun toSuppliedResourceId(
  supplier: String,
  resource: String,
  params: SKJSON.CJSON,
): String {
  `${supplier}_${toResourceId(resource, params)}`;
}

fun collectionForName(name: String): Collection {
  Collection::forName(name)
}

fun lazyForName(name: String): LazyCollection {
  LazyCollection::forName(name)
}

fun collectionsByName(collections: Map<String, Collection>): SKJSON.CJObject {
  fields = mutable Vector[];
  collections.each((k, c) -> fields.push((k, SKJSON.CJString(c.getId()))));
  SKJSON.CJObject(SKJSON.CJFields::create(fields.toArray(), x -> x));
}

fun runWithResult<T>(f: mutable SKStore.Context ~> T): Result<T, .Exception> {
  SKStore.runWithResult(f, None(), false, getFork())
}

private fun addSubscription(
  context: mutable SKStore.Context,
  waitable: Waitable,
): void {
  subscriptions = context
    .getPersistent(kSubscriptionsKey)
    .map(SubscriptionsFile::type) match {
  | Some(subscriptions) -> subscriptions.value
  | _ -> Array[]
  };
  context.setPersistent(
    kSubscriptionsKey,
    SubscriptionsFile(subscriptions.concat(Array[waitable])),
  )
}

private fun getSubscriptions(
  context: mutable SKStore.Context,
): Array<Waitable> {
  subcriptions = context
    .getPersistent(kSubscriptionsKey)
    .map(SubscriptionsFile::type) match {
  | Some(subscriptions) -> subscriptions.value
  | _ -> Array[]
  };
  context.removePersistent(kSubscriptionsKey);
  subcriptions
}

module end;
