module SkipRuntime;

base class IError uses Show
base class Parameters uses Orderable, Show
base class Collections {
  fun maybeGet(name: String): ?Collection;
  fun each((String, Collection) -> void): void;

  fun get(name: String): Collection {
    this.maybeGet(name) match {
    | Some(c) -> c
    | _ -> invariant_violation(`Unknown collection ${name}`)
    }
  }
}

base class KeyConverter<K: frozen & Orderable> {
  fun fromKey(SKStore.Key): K;
  fun toKey(K): SKStore.Key;
  fun fromString(String): K;
}

base class ValueConverter<V: frozen> {
  fun fromFile(SKStore.File): V;
  fun toFile(V): SKStore.File;
}

base class ErrorConverter<E: frozen> {
  fun fromError(IError): E;
  fun toError(E): IError;
}

base class ParamsConverter<P: frozen> {
  fun fromParams(Parameters): P;
  fun toParams(P): Parameters;
}

class ConverterPair<K: frozen & Orderable, V: frozen>(
  key: KeyConverter<K>,
  value: ValueConverter<V>,
) {
  fun fromSKStore(v: (SKStore.Key, Array<SKStore.File>)): Entry {
    TEntry::create(this.key.fromKey(v.i0), v.i1.map(this.value.fromFile))
  }

  fun toSKStore(v: Entry): (SKStore.Key, Array<SKStore.File>) {
    entry = castEntry<K, V>(v);
    (this.key.toKey(entry.key()), entry.values.map(this.value.toFile))
  }
}

base class Reducer<V1: frozen, V2: frozen>(initial: V2) {
  fun add(acc: V2, value: V1): V2;
  fun remove(acc: V2, value: V1): ?V2;
  fun valueConverter(): SKStore.File ~> V1;
  fun accConverter(): ValueConverter<V2>;
}

/**
 * The type of a reactive function mapping over an arbitrary collection.
 * For each key & values in the input collection (of type K1/V1 respectively),
 * produces some key/value pairs for the output collection (of type K2/V2 respectively)
 * @param key - a key found in the input collection
 * @param values - the values mapped to by `key` in the input collection
 * @returns an iterable of key/value pairs to output for the given input(s)
 */
base class Mapper<
  K1: frozen & Orderable,
  V1: frozen,
  K2: frozen & Orderable,
  V2: frozen,
> {
  fun mapEntry(
    key: K1,
    values: mutable SKStore.NonEmptyIterator<V1>,
  ): mutable Iterator<(K2, V2)>;

  fun converters(): ConverterPair<K2, V2>;
}

base class LazyCompute<K: frozen & Orderable, V: frozen> {
  fun compute(self: LazyCollection<K, V>, key: K): Array<V>;
}

base class ExternalService {
  fun subscribe(
    instance: String,
    writer: CollectionWriter,
    resource: String,
    params: Parameters,
  ): void;

  fun unsubscribe(instance: String): void;

  fun shutdown(): Float;
}

base class Resource {
  fun materialize(collections: Collections): Collection;
}

base class Snapshot {
  fun snapshot(entries: Array<Entry>): String;
  fun snapshotLookup(entry: Entry): String;
}

base class ResourceBuilder {
  fun parseParameters(params: String): Parameters;
  fun produce(params: Parameters): Resource;
  fun snapshot(): Snapshot;
}

base class Entry uses Downcastable

class TEntry<K: frozen & Orderable, V: frozen>{
  private key_: ?K = None(),
  values: Array<V> = Array[],
} extends Entry {
  //
  static fun create(key: K, values: Array<V>): TEntry<K, V> {
    TEntry{key_ => Some(key), values};
  }

  @no_inline
  static fun const_type_id(): Int {
    SKStore.const_typed_symbol(TEntry<K, V>{});
  }

  fun key(): K {
    this.key_.fromSome()
  }

  fun type_id(): Int {
    static::const_type_id()
  }
}

fun castEntry<K: frozen & Orderable, V: frozen>(entry: Entry): TEntry<K, V> {
  cast(entry, TEntry<K, V>);
}

fun instanceOfEntry<K: frozen & Orderable, V: frozen>(entry: Entry): Bool {
  instanceOf(entry, TEntry<K, V>);
}

base class Data {
  fun parse(values: String): Array<Entry>;
  fun toCollection(context: mutable SKStore.Context, name: String): Collection;
}

class InitialData<K: frozen & Orderable, V: frozen>(
  entries: Array<TEntry<K, V>>,
  converters: ConverterPair<K, V>,
  parsers: String ~> Array<Entry>,
) extends Data {
  fun toCollection(context: mutable SKStore.Context, name: String): Collection {
    values = this.entries.map(v -> {
      entry = castEntry<K, V>(v);
      (
        this.converters.key.toKey(entry.key()),
        entry.values.map(this.converters.value.toFile),
      )
    });
    iDirName = SKStore.DirName::create(`/${name}/`);
    context.mkdirMulti(iDirName, values);
    iHdl = SKStore.EHandle(kNOTYPE_KEY, kNOTYPE_VALUE, iDirName);
    TCollection(iHdl, this.converters);
  }

  fun parse(values: String): Array<Entry> {
    this.parsers(values)
  }
}

base class Service {
  fun initialData(): Map<String, Data>;
  fun resourceBuilders(): Map<String, ResourceBuilder>;
  fun externalServices(): Map<String, ExternalService>;

  fun createGraph(inputCollections: Collections): Collections;
}

value class Values(entries: Array<Entry>, watermark: String)

base class Executor {
  fun resolve(): void;
  fun reject(exc: .Exception): void;
}

base class Notifier {
  fun subscribed(): void;

  fun notify(values: Array<Entry>, watermark: String, updates: Bool): void;

  fun close(): void;
}

// ************ Typed ************************

base class TResourceBuilder<P: frozen> extends ResourceBuilder {
  fun build(params: P): Resource;
  fun fromParameters(params: Parameters): P;

  fun produce(params: Parameters): Resource {
    this.build(this.fromParameters(params))
  }
}

base class TResource<K: frozen & Orderable, V: frozen, CS: Collections> extends
  Resource,
{
  fun materialize(collections: Collections): Collection {
    this.instantiate(this.fromCollections(collections))
  }

  fun instantiate(collections: CS): TCollection<K, V>;
  fun fromCollections(Collections): CS;
}

base class TService<I: Collections, O: Collections> extends Service {
  fun createGraph(inputs: Collections): Collections {
    this.createTypedGraph(this.fromCollections(inputs))
  }

  fun createTypedGraph(I): O;
  fun fromCollections(Collections): I;
}

module end;
