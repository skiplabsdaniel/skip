module SkipRuntime;

const kGarbageMillis: Int = 30000;

class IdentityMapper<K: frozen & Orderable, V: frozen>(
  converters_: ConverterPair<K, V>,
) extends Mapper<K, V, K, V> {
  fun mapEntry(
    key: K,
    values: mutable SKStore.NonEmptyIterator<V>,
  ): mutable Iterator<(K, V)> {
    vec = mutable Vector[];
    values.values().each(v -> vec.push((key, v)));
    vec.iterator()
  }

  fun converters(): ConverterPair<K, V> {
    this.converters_
  }
}

class ReadInCreatorException() extends Exception {
  fun getMessage(): String {
    "A collection cannot be read in the function that creates it."
  }
}

class ExistingResourceException() extends Exception {
  fun getMessage(): String {
    "A resource instance with specified identifier already exists."
  }
}

class UseExternalResourceException() extends Exception {
  fun getMessage(): String {
    "useExternalResource is not allowed in a lazy computation graph."
  }
}

class UnknownCollectionError(resourceInstanceId: String) extends Exception {
  fun getMessage(): String {
    `Unknown resource instance '${this.resourceInstanceId}'`
  }
}

class ResourceInstanceInUse(resourceInstanceId: String) extends Exception {
  fun getMessage(): String {
    `Resource instance '${this.resourceInstanceId}' cannot be subscribed twice.`
  }
}

class SKStoreMapper<
  K1: frozen & Orderable,
  V1: frozen,
  K2: frozen & Orderable,
  V2: frozen,
>(
  mapper: Mapper<K1, V1, K2, V2>,
  converters: ConverterPair<K1, V1>,
) {
  fun map(
    ctx: mutable SKStore.Context,
    writer: mutable SKStore.TWriter<SKStore.Key, SKStore.File>,
    key: SKStore.Key,
    values: mutable SKStore.NonEmptyIterator<SKStore.File>,
  ): void {
    pushContext(ctx);
    try {
      mc = this.mapper.converters();
      for (entry in this.mapper.mapEntry(
        this.converters.key.fromKey(key),
        values.nonEmptyMap(this.converters.value.fromFile),
      )) {
        writer.append(mc.key.toKey(entry.i0), mc.value.toFile(entry.i1))
      };
      popContext();
    } catch {
    | ex ->
      popContext();
      throw ex
    }
  }
}

class Params(params: Parameters) extends SKStore.File uses Orderable {
  fun compare(other: Params): Order {
    this.params.compare(other.params)
  }
  fun toString(): String {
    this.params.toString()
  }
}

class ResourceCollections(
  value: SKStore.EHandle<SKStore.SID, ResourceInfo>,
) extends SKStore.File

class ServiceDefinition(
  runId: String,
  service: Service,
  executor: Executor,
) extends SKStore.File

class Handle(
  value: SKStore.EHandle<SKStore.Key, SKStore.File>,
) extends SKStore.File

class StatusHandle(
  value: SKStore.EHandle<SKStore.DirName, SKStore.IntFile>,
) extends SKStore.File

class ResourceCollection(value: Map<String, Collection>) extends SKStore.File

class ResourceDef(
  name: String,
  params: Parameters,
) extends SKStore.File, SKStore.Key {
  //
  fun toString(): String {
    `${this.name}:${this.params}`
  }
}

class ResourceStatus(
  loadable: SKStore.DirName,
  status: Status<IError>,
) extends SKStore.File {}

class ServiceFile(value: Collections, inputs: Collections) extends SKStore.File

base class Status<E: IError>(
  created: Int,
  modified: Int,
  initialiazed: ?Result<void, IError>,
) uses Show {
  children =
  | Loading()
  | Error(error: E)
  | Ok()

  static fun create<E: IError>(): Status<E> {
    time = Time.time_ms();
    Loading<E>(time, time, None())
  }

  fun ok(): Status<E> {
    Ok(this.created, Time.time_ms(), this.initialiazed)
  }

  fun err(error: E): Status<E> {
    Error(error, this.created, Time.time_ms(), this.initialiazed)
  }

  fun init(error: ?E): Status<E> {
    !this.initialiazed = Some(
      error.map(e -> Failure(e)).default(Success(void)),
    );
    this
  }

  fun unTyped(): Status<IError>
  | Loading(created, modified, initialiazed) ->
    Loading<IError>(created, modified, initialiazed)
  | Error(e, created, modified, initialiazed) ->
    Error<IError>(e, created, modified, initialiazed)
  | Ok(created, modifie, initialiazed) ->
    Ok<IError>(created, modifie, initialiazed)

  fun toString(): String
  | Loading(created, modified, initialiazed) ->
    `Loading{created: ${created}, modified: ${modified}, initialiazed: ${initialiazed.isSome()}}`
  | Error(error, created, modified, initialiazed) ->
    `Error{error: ${error}, created: ${created}, modified: ${modified}, initialiazed: ${initialiazed.isSome()}}`
  | Ok(created, modified, initialiazed) ->
    `Ok{created: ${created}, modified: ${modified}, initialiazed: ${initialiazed.isSome()}}`
}

class StatusFile(status: Status<IError>) extends SKStore.File

class RequestStatuses(statuses: Array<ResourceStatus>) extends SKStore.File {
  //
  fun getResult<T>(values: T): GetResult<T> {
    errors = mutable Vector[];
    for (resourceStatus in this.statuses) {
      resourceStatus.status match {
      | Error(error, _, _, _) -> errors.push(error)
      | _ -> void
      }
    };
    GetResult(values, errors.toArray())
  }

  fun isLoading(): Bool {
    for (resourceStatus in this.statuses) {
      resourceStatus.status match {
      | Loading _ -> break true
      | Error _
      | Ok _ ->
        void
      }
    } else {
      false
    }
  }

  fun getErrors(): Array<IError> {
    errors = mutable Vector[];
    for (resourceStatus in this.statuses) {
      resourceStatus.status match {
      | Error(error, _, _, _) -> errors.push(error)
      | Loading _
      | Ok _ ->
        void
      }
    };
    errors.toArray()
  }
}

class RemoteSpecifiers(
  value: Map<String, ExternalService>,
) extends SKStore.File

class ResourceInfo(
  name: String,
  collection: Collection,
  statusRef: SKStore.DirName,
  session: String,
) extends SKStore.File {
  fun getResult<T>(context: mutable SKStore.Context, values: T): GetResult<T> {
    SKStore.EHandle(
      SKStore.IID::keyType,
      RequestStatuses::type,
      this.statusRef.sub("all"),
    ).maybeGet(context, SKStore.IID(0)) match {
    | Some(statuses) -> statuses.getResult(values)
    | _ -> GetResult(values, Array[])
    }
  }
}

fun initCtx(): SKStore.Context {
  SKStore.Context::create{}
}

fun unTypedFile(x: SKStore.File): SKStore.File {
  x
}

fun buildResourcesGraph(
  context: mutable SKStore.Context,
  definitionHdl: SKStore.EHandle<SKStore.UnitID, ServiceDefinition>,
  statusHdl: SKStore.EHandle<SKStore.UnitID, ResourceStatus>,
  servicesHdl: SKStore.EHandle<SKStore.SID, ServiceFile>,
): void {
  dirname = kResourceSessionDir;
  dDirname = dirname.sub("data");
  resourcesHdl = context.mkdir(
    SKStore.SID::keyType,
    ResourceDef::type,
    dirname,
  );
  _ = context.mkdir(
    SKStore.SID::keyType,
    SKStore.IntFile::type,
    kResourceGarbageDir,
  );
  idbyresourceHdl = resourcesHdl.map(
    ResourceDef::keyType,
    SKStore.StringFile::type,
    context,
    dirname.sub("idbyresource"),
    (_c, writer, key, it) ~> {
      writer.set(it.first, SKStore.StringFile(key.value));
    },
  );
  availablesHdl = idbyresourceHdl.map(
    ResourceDef::keyType,
    SKStore.IntFile::type,
    context,
    kResourceAvailablesDir,
    (_c, writer, key, _it) ~> {
      // map to ignore array changes
      // to prevent recompute on each add/remove session
      writer.set(key, SKStore.IntFile(1))
    },
  );
  statusesHdl = availablesHdl.map(
    ResourceDef::keyType,
    SKStore.StringFile::type,
    context,
    kResourceStatusDir,
    (context, writer, key, _it) ~> {
      resourceId = toResourceId(key.name, key.params);
      statusRef = dirname.sub(resourceId);
      // Status graph
      sStatusHdl = context
        .mkdir(
          SKStore.DirName::keyType,
          StatusFile::type,
          statusRef.sub("status"),
          Array[],
          true,
        )
        .map(
          SKStore.UnitID::keyType,
          ResourceStatus::type,
          context,
          statusRef.sub("statuses"),
          (_ctx, writer, key, it) ~> {
            writer.set(
              SKStore.UnitID::singleton,
              ResourceStatus(key, it.first.status),
            );
          },
        );
      _ = sStatusHdl.map(
        SKStore.UnitID::keyType,
        RequestStatuses::type,
        context,
        statusRef.sub("all"),
        (ctx, writer, key, it) ~> {
          statuses = statusHdl.getArray(ctx, key).concat(it.toArray());
          requestStatuses = RequestStatuses(statuses);
          writer.set(key, requestStatuses);
        },
      );
      writer.set(key, SKStore.StringFile(statusRef.toString()));
    },
  );
  instancesHdl = statusesHdl.map(
    ResourceDef::keyType,
    ResourceInfo::type,
    context,
    kResourceInstancesDir,
    (context, writer, key, it) ~> {
      resourceId = toResourceId(key.name, key.params);
      statusRef = SKStore.DirName::create(it.first.value);
      (runId, service) = definitionHdl.maybeGet(
        context,
        SKStore.UnitID::singleton,
      ) match {
      | Some(definition) -> (definition.runId, definition.service)
      | _ -> return void
      };
      pushContext(context);
      try {
        resourceBuilder = service.resourceBuilders().get(key.name);
        resource = resourceBuilder.produce(key.params);
        collections = servicesHdl.get(context, SKStore.SID(runId)).value;
        collection = resource.materialize(collections);
        writer.set(key, ResourceInfo(resourceId, collection, statusRef, runId));
        popContext()
      } catch {
      | ex ->
        popContext();
        throw ex
      }
    },
  );
  // Copy the computed collection
  //   - Ensure the name of the resource result
  //   - Avoid destruction in case of graph recompute.
  instancesCopyHdl = statusesHdl.map(
    ResourceDef::keyType,
    Handle::type,
    context,
    kResourceInstancesDir.sub("copy"),
    (context, writer, key, it) ~> {
      resourceId = toResourceId(key.name, key.params);
      obsName = dDirname.sub(resourceId);
      hdl = context
        .mkdir(
          ResourceDef::keyType,
          SKStore.StringFile::type,
          kResourceInstancesDir.sub("copy").sub(resourceId),
          it.toArray().map(v -> (key, v)),
        )
        .map(
          kNOTYPE_KEY,
          kNOTYPE_VALUE,
          context,
          obsName,
          (context, writer, key, _it) ~> {
            info = instancesHdl.get(context, key);
            info.collection.skitems(context).each((kv) -> {
              writer.setArray(kv.i0, kv.i1.collect(Array))
            });
          },
        );
      writer.set(key, Handle(hdl))
    },
  );
  _ = instancesHdl.map(
    ResourceDef::keyType,
    ResourceInfo::type,
    context,
    kResourceCollectionsDir,
    (context, writer, key, it) ~> {
      info = it.first;
      resourceData = instancesCopyHdl.get(context, key).value;
      !info.collection = info.collection.withHandle(resourceData);
      writer.set(key, info)
    },
  );
}

fun initService(
  service: Service,
  executor: Executor,
): Result<void, .Exception> {
  if (SKStore.gHasContext() == 0) {
    SKStore.gContextInit(initCtx());
  };
  runId = Ksuid::create().toString();
  SKStore.runWithResult(context ~> {
    if (context.unsafeMaybeGetEagerDir(kSessionDir) is None()) {
      sessionHdl = context.mkdir(
        SKStore.UnitID::keyType,
        ServiceDefinition::type,
        kSessionDir,
        Array[
          (
            SKStore.UnitID::singleton,
            ServiceDefinition(runId, service, executor),
          ),
        ],
      );
      servicesHdl = sessionHdl.map(
        SKStore.SID::keyType,
        ServiceFile::type,
        context,
        kGraphDir,
        (ctx, writer, _key, it) ~> {
          serviceDef = it.first;
          pushContext(ctx);
          inputCollections = serviceDef.service
            .initialData()
            .map((name, initialData) -> initialData.toCollection(ctx, name));
          inputs = CollectionsMap(inputCollections);
          try {
            writer.set(
              SKStore.SID(serviceDef.runId),
              ServiceFile(serviceDef.service.createGraph(inputs), inputs),
            );
            popContext()
          } catch {
          | ex ->
            popContext();
            throw ex
          }
        },
      );
      // Service status
      statusDefHdl = context.mkdir(
        SKStore.DirName::keyType,
        StatusFile::type,
        kSessionDir.sub("status"),
      );
      statusHdl = statusDefHdl.map(
        SKStore.UnitID::keyType,
        ResourceStatus::type,
        context,
        kSessionDir.sub("statuses"),
        (_ctx, writer, key, it) ~> {
          writer.set(
            SKStore.UnitID::singleton,
            ResourceStatus(key, it.first.status),
          );
        },
      );
      buildResourcesGraph(context, sessionHdl, statusHdl, servicesHdl)
    } else {
      // Can be done because it's only used on test, we can add a environment variable or some way to protect that usage
      _ = closeService_(context);
      sessionHdl = SKStore.EHandle(
        SKStore.UnitID::keyType,
        ServiceDefinition::type,
        kSessionDir,
      );
      statusHdl = SKStore.EHandle(
        SKStore.DirName::keyType,
        StatusFile::type,
        kSessionDir.sub("status"),
      );
      toclean = mutable Vector[];
      statusHdl.items(context).each(kf -> {
        kf.i1.next().each(_f -> toclean.push(SKStore.DirName::keyType(kf.i0)))
      });
      toclean.each(key -> statusHdl.writeArray(context, key, Array[]));
      sessionHdl.writeArray(context, SKStore.UnitID::singleton, Array[]);
      context.update();
      sessionHdl.writeArray(
        context,
        SKStore.UnitID::singleton,
        Array[ServiceDefinition(runId, service, executor)],
      );
    };
    updateContext(context);
    checkSubcriptions(context, executor);
  })
}

fun closeService_(
  context: mutable SKStore.Context,
  update: Bool = true,
): Array<Float> {
  resourceHdl = SKStore.EHandle(
    SKStore.SID::keyType,
    ResourceDef::type,
    kResourceSessionDir,
  );
  todestroy = mutable Vector[];
  resourceHdl.items(context).each(kf -> {
    kf.i1.next().each(_f -> todestroy.push(kf.i0))
  });
  todestroy.each(key -> destroyReactiveResource(context, key));
  sessionHdl = SKStore.EHandle(
    SKStore.UnitID::keyType,
    ServiceDefinition::type,
    kSessionDir,
  );
  handles = sessionHdl.maybeGet(context, SKStore.UnitID::singleton) match {
  | Some(def) ->
    def.service
      .externalServices()
      .values()
      .map(es -> es.shutdown())
      .collect(Array)
  | _ -> Array[]
  };
  if (update) context.update();
  handles;
}

fun closeService(): Result<Array<Float>, .Exception> {
  SKStore.runWithResult(ctx ~> closeService_(ctx))
}

class LinkToResource(
  supplier: ExternalService,
  instance: String,
  writer: CollectionWriter,
  name: String,
  params: Parameters,
) extends SKStore.Postponable {
  //
  fun perform(context: mutable SKStore.Context): void {
    this.writer.status(context, Status::create());
    pushContext(context);
    this.supplier.subscribe(this.instance, this.writer, this.name, this.params);
    popContext();
    addSubscription(context, this.writer.dirName);
  }
}

class CloseExternalService(
  supplier: ExternalService,
  instance: String,
  dirName: SKStore.DirName,
  definition: ExternalServiceDef,
) extends SKStore.Postponable {
  fun perform(context: mutable SKStore.Context): void {
    if (isClosed(context, this.definition)) {
      return void;
    };
    // Clear status
    context.maybeGetEagerDir(this.dirName) match {
    | Some(dir) ->
      dirname = sessionId(context, dir) match {
      | Some(sId) -> kResourceSessionDir.sub(sId).sub("status")
      | _ -> kSessionDir.sub("status")
      };
      shdl = SKStore.EHandle(
        SKStore.DirName::keyType,
        StatusFile::type,
        dirname,
      );
      shdl.writeArray(context, this.dirName, Array[])
    | _ -> void
    };
    pushContext(context);
    this.supplier.unsubscribe(this.instance);
    popContext();
    addClosed(context, this.definition);
  }
}

/**
 * Creates a lazy reactive collection.
 * @param compute - the function to compute entries of the lazy collection
 * @param params - any additional parameters to the computation
 * @returns The resulting lazy collection
 */
fun createLazyCollection<K: frozen & Orderable, V: frozen>(
  compute: LazyCompute<K, V>,
  converters: ConverterPair<K, V>,
): LazyCollection<K, V> {
  getContext() match {
  | Some(context) ->
    collectionId = `collection_${SKStore.genSym(0)}`;
    dirName = subDirName(context, collectionId);
    lhdl = SKStore.LHandle::create(
      kNOTYPE_KEY,
      kNOTYPE_VALUE,
      context,
      dirName,
      (ctx, self, key) ~> {
        pushContext(ctx);
        try {
          res = compute.compute(
            LazyCollection(self, converters),
            converters.key.fromKey(key),
          );
          popContext();
          res.map(converters.value.toFile)
        } catch {
        | ex ->
          popContext();
          throw ex
        }
      },
    );
    LazyCollection(lhdl, converters)

  | _ -> invariant_violation("Store context must be specified.")
  }
}

fun jsonExtract(from: SKJSON.CJObject, pattern: String): Array<SKJSON.CJSON> {
  fieldsList = SKJSON.PatternParser::mcreate(pattern)
    .toplevelPattern()
    .pmatch(from)
    .collect(Array);
  values = mutable Vector[];
  fieldsList.each(fields -> {
    array = fields.collect(Array).map(field -> {
      cjfields = SKJSON.CJFields::create(Array[field], x -> x);
      SKJSON.CJObject(cjfields)
    });
    values.push(SKJSON.CJArray(array));
  });
  values.toArray()
}

fun useExternalCollection<K: frozen & Orderable, V: frozen>(
  supplier: String,
  resource: String,
  params: Parameters,
  converters: ConverterPair<K, V>,
): TCollection<K, V> {
  getContext() match {
  | Some(context) ->
    context.currentArrow().each(a -> {
      context.unsafeMaybeGetDir(a.childName) match {
      | Some(SKStore.LazyDir _) -> throw UseExternalResourceException()
      | _ -> void
      }
    });
    sessionHdl = SKStore.EHandle(
      SKStore.UnitID::keyType,
      ServiceDefinition::type,
      kSessionDir,
    );
    externalServices = sessionHdl
      .get(context, SKStore.UnitID::singleton)
      .service.externalServices();
    externalSupplier = externalServices.get(supplier);
    collectionId = toSuppliedResourceId(supplier, resource, params);
    dirName = subDirName(context, collectionId);
    paramsDir = dirName.sub("params");
    dataDir = dirName.sub("data");
    hdl = context.mkdir(
      SKStore.UnitID::keyType,
      Params::type,
      paramsDir,
      Array[(SKStore.UnitID::singleton, Params(params))],
    );
    collectionHdl = hdl.map(
      SKStore.UnitID::keyType,
      Handle::type,
      context,
      dirName,
      (context, writer, key, it) ~> {
        storeDir = dirName.sub("store");
        (optOnCreate, onDelete) = getCloseExternalService(
          context,
          storeDir,
        ) match {
        | Some(onDelete) -> (None(), onDelete)
        | _ ->
          definition = ExternalServiceDef(supplier, resource, params);
          instance = Ksuid::create().toString();
          (
            Some(
              LinkToResource(
                externalSupplier,
                instance,
                CollectionWriter(storeDir),
                resource,
                it.first.params,
              ),
            ),
            CloseExternalService(
              externalSupplier,
              instance,
              storeDir,
              definition,
            ),
          )
        };
        store = context.mkdir(
          kNOTYPE_KEY,
          kNOTYPE_VALUE,
          storeDir,
          Array[],
          true,
          optOnCreate,
          Some(onDelete),
        );
        writer.set(key, Handle(store));
      },
    );
    TCollection(
      hdl.map(
        kNOTYPE_KEY,
        kNOTYPE_VALUE,
        context,
        dataDir,
        (context, writer, key, _it) ~> {
          remote = collectionHdl.get(context, key).value;
          remote.items(context).each(kv -> {
            writer.setArray(kv.i0, kv.i1.collect(Array))
          });
        },
      ),
      converters,
    )
  | _ -> invariant_violation("Store context must be specified.")
  }
}

base class Collection {
  fun getId(): String;
  fun handle(): SKStore.EHandle<SKStore.Key, SKStore.File>;
  fun withHandle(SKStore.EHandle<SKStore.Key, SKStore.File>): Collection;
  fun getAll(): Array<Entry>;
  fun lookupValues(key: SKStore.Key): Array<SKStore.File>;
  fun lookup(strKey: String): Entry;
  fun subscribe(
    identifier: String,
    session: Int,
    from: SKStore.Tick,
    notify: (Array<Entry>, SKStore.Tick, Bool) ~> void,
    close: () ~> void,
  ): void;

  fun unsafeCast<K: frozen & Orderable, V: frozen>(
    converters: ConverterPair<K, V>,
  ): TCollection<K, V>;

  fun getToSKStore(): Entry ~> (SKStore.Key, Array<SKStore.File>);
  fun skitems(
    mutable SKStore.Context,
  ): mutable Iterator<(SKStore.Key, mutable Iterator<SKStore.File>)>;
}

class TCollection<K: frozen & Orderable, V: frozen>(
  hdl: SKStore.EHandle<SKStore.Key, SKStore.File>,
  converters: ConverterPair<K, V>,
) extends Collection {
  //
  static fun forName<K: frozen & Orderable, V: frozen>(
    name: String,
    converters: ConverterPair<K, V>,
  ): TCollection<K, V> {
    hdl = SKStore.EHandle<SKStore.Key, SKStore.File>(
      kNOTYPE_KEY,
      kNOTYPE_VALUE,
      SKStore.DirName::create(name),
    );
    TCollection(hdl, converters)
  }

  fun getId(): String {
    this.hdl.dirName.toString();
  }

  fun handle(): SKStore.EHandle<SKStore.Key, SKStore.File> {
    this.hdl
  }

  fun withHandle(hdl: SKStore.EHandle<SKStore.Key, SKStore.File>): Collection {
    !this.hdl = hdl;
    this
  }

  /**
   * Get all values mapped to by some key of an eager reactive collection.
   */
  fun getArray(key: K): Array<V> {
    getContext() match {
    | Some(context) ->
      dir = context.unsafeGetEagerDir(this.hdl.dirName);
      if (dir.creator == context.currentArrow()) {
        throw ReadInCreatorException()
      };
      dir
        .getArray(context, this.converters.key.toKey(key))
        .map(this.converters.value.fromFile)
    | _ -> invariant_violation("Store context must be specified.")
    }
  }

  fun lookupValues(key: SKStore.Key): Array<SKStore.File> {
    getContext() match {
    | Some(context) ->
      dir = context.unsafeGetEagerDir(this.hdl.dirName);
      if (dir.creator == context.currentArrow()) {
        throw ReadInCreatorException()
      };
      dir.getArray(context, key)
    | _ -> invariant_violation("Store context must be specified.")
    }
  }

  fun lookup(strKey: String): Entry {
    keyConv = this.converters.key;
    key = keyConv.fromString(strKey);
    values = this.lookupValues(keyConv.toKey(key));
    CEntry::create(key, values.map(this.converters.value.fromFile))
  }

  /**
   * Get a value of an eager reactive collection, if one exists.
   * If multiple values are mapped to by the key, any of them can be returned.
   * @returns the value for this `key`, or null if no such value exists
   */
  fun getUnique(key: K): ?V {
    value = this.getArray(key);
    if (value.size() == 1) Some(value[0]) else None();
  }

  /**
   * Create a new eager collection by mapping some computation over this one
   * @param mapper - function to apply to each element of this collection
   * @returns The resulting (eager) output collection
   */
  fun map<K2: frozen & Orderable, V2: frozen>(
    mapper: Mapper<K, V, K2, V2>,
  ): TCollection<K2, V2> {
    this.map_(mapper, None())
  }

  /**
   * Create a new eager reactive collection by mapping some computation `mapper` over this
   * one and then reducing the results with `reducer`
   * @param mapper - function to apply to each element of this collection
   * @param reducer - function to combine results of the `mapper`
   * @returns An eager collection containing the output of the reducer
   */
  fun mapReduce<K2: frozen & Orderable, V2: frozen, V3: frozen>(
    mapper: Mapper<K, V, K2, V2>,
    reducer: Reducer<V2, V3>,
  ): TCollection<K2, V3> {
    getContext() match {
    | Some(context) ->
      collectionId = `collection_${SKStore.genSym(0)}`;
      dirName = this.hdl.dirName.sub(collectionId);
      converters = mapper.converters();
      hdl = this.hdl.mapReduce(
        kNOTYPE_KEY,
        kNOTYPE_VALUE,
        context,
        dirName,
        SKStoreMapper(mapper, this.converters).map,
        accReducer(reducer),
      );
      TCollection(hdl, ConverterPair(converters.key, reducer.accConverter()))
    | _ -> invariant_violation("Store context must be specified.")
    }
  }

  fun reduce<V2: frozen>(reducer: Reducer<V, V2>): TCollection<K, V2> {
    this.mapReduce(IdentityMapper(this.converters), reducer)
  }

  fun unsafeCast<K2: frozen & Orderable, V2: frozen>(
    converters: ConverterPair<K2, V2>,
  ): TCollection<K2, V2> {
    hdl = SKStore.EHandle(kNOTYPE_KEY, kNOTYPE_VALUE, this.hdl.dirName);
    TCollection(hdl, converters)
  }

  fun nativeMapReduce<K2: frozen & Orderable, V2: frozen>(
    mapper: Mapper<K, V, K2, V2>,
    reducer: String,
    value: V2 ~> Int,
    create: Int ~> V2,
  ): TCollection<K2, V2> {
    converters = mapper.converters();
    this.nativeMapReduceImpl(
      mapper,
      this.eReducer(
        reducer,
        v ~> value(converters.value.fromFile(v)),
        v ~> converters.value.toFile(create(v)),
      ),
    )
  }

  fun nativeReduce(
    reducer: String,
    value: V ~> Int,
    create: Int ~> V,
  ): TCollection<K, V> {
    this.nativeMapReduce(
      IdentityMapper(this.converters),
      reducer,
      value,
      create,
    )
  }

  /**
   * Create a new eager collection by keeping only the elements whose keys are in
   * the given ranges.
   */
  fun sliced(ranges: Array<(K, K)>): TCollection<K, V> {
    this.map_(IdentityMapper(this.converters), Some(ranges))
  }

  /**
   * Create a new eager collection by keeping the given number of the first elements.
   */
  fun take(limit: Int): TCollection<K, V> {
    getContext() match {
    | Some(context) ->
      collectionId = `collection_${SKStore.genSym(0)}`;
      dirName = this.hdl.dirName.sub(collectionId);
      resHdl = this.hdl.filter(
        context,
        dirName,
        limit,
        noFilter,
        countElementAsOne,
        removeElementAsOne,
        None(),
      );
      TCollection(resHdl, this.converters)
    | _ -> invariant_violation("Store context must be specified.")
    }
  }

  /**
   * Combine some eager collections into one, associating with each key _all_ values
   * associated with that key in any of the input collections.
   * @param others - some other eager collections of compatible type
   * @returns The resulting combination of all input key/value pairs
   */
  fun merge(others: Array<TCollection<K, V>>): TCollection<K, V> {
    getContext() match {
    | Some(context) ->
      collectionId = `collection_${SKStore.genSym(0)}`;
      dirName = this.hdl.dirName.sub(collectionId);
      hdl = SKStore.EHandle::multiMap(
        kNOTYPE_KEY,
        kNOTYPE_VALUE,
        context,
        Array[this].concat(others).map(c ->
          c match {
          | ci @ Collection _ -> (ci.handle(), (identityMap, None()))
          }
        ),
        dirName,
      );
      TCollection(hdl, this.converters)
    | _ -> invariant_violation("Store context must be specified.")
    }
  }

  /**
   * Get the current number of elements in the collection
   * @returns The current number of elements in the collection
   */
  fun size(): Int {
    getContext() match {
    | Some(context) ->
      dir = context.unsafeGetEagerDir(this.hdl.dirName);
      if (dir.creator == context.currentArrow()) {
        throw ReadInCreatorException()
      };
      dir.size(context)
    | _ -> invariant_violation("Store context must be specified.")
    }
  }

  fun getAll(): Array<Entry> {
    getContext() match {
    | Some(context) ->
      values = mutable Vector<Entry>[];
      dir = context.unsafeGetEagerDir(this.hdl.dirName);
      for (kv in dir.unsafeGetFileIter()) {
        (key, files) = kv;
        values.push(
          TEntry::create(
            this.converters.key.fromKey(key),
            files.collect(Array).map(this.converters.value.fromFile),
          ),
        );
      };
      values.toArray()
    | _ -> invariant_violation("Store context must be specified.")
    }
  }

  fun skitems(
    context: mutable SKStore.Context,
  ): mutable Iterator<(SKStore.Key, mutable Iterator<SKStore.File>)> {
    this.hdl.items(context)
  }

  fun items(): mutable Iterator<(K, mutable Iterator<V>)> {
    getContext() match {
    | Some(context) ->
      this.skitems(context).map(v ->
        (
          this.converters.key.fromKey(v.i0),
          v.i1.map(this.converters.value.fromFile),
        )
      )
    | _ -> invariant_violation("Store context must be specified.")
    }
  }

  fun subscribe(
    identifier: String,
    session: Int,
    from: SKStore.Tick,
    notify: (Array<Entry>, SKStore.Tick, Bool) ~> void,
    close: () ~> void,
  ): void {
    getContext() match {
    | Some(context) ->
      context.subscribe(
        session,
        SKStore.NWatch(
          identifier,
          from,
          (_dirName, values, tick, update) ~> {
            notify(values.map(this.converters.fromSKStore), tick, update)
          },
          close,
          true,
        ),
        None(),
        Array[
          SKStore.DirSub(this.hdl.dirName, "", SKStore.OJSON(Array[]), (__) ~>
            None()
          ),
        ],
        Some(from),
      )
    | _ -> invariant_violation("Store context must be specified.")
    }
  }

  fun getToSKStore(): Entry ~> (SKStore.Key, Array<SKStore.File>) {
    this.converters.toSKStore
  }

  private fun map_<K2: frozen & Orderable, V2: frozen>(
    mapper: Mapper<K, V, K2, V2>,
    rangeOpt: ?Array<(K2, K2)> = None(),
  ): TCollection<K2, V2> {
    getContext() match {
    | Some(context) ->
      collectionId = `collection_${SKStore.genSym(0)}`;
      dirName = this.hdl.dirName.sub(collectionId);
      converters = mapper.converters();
      hdl = this.hdl.map(
        kNOTYPE_KEY,
        kNOTYPE_VALUE,
        context,
        dirName,
        SKStoreMapper(mapper, this.converters).map,
        rangeOpt.map(v ->
          v.map(r ->
            SKStore.KeyRange::create(
              converters.key.toKey(r.i0),
              converters.key.toKey(r.i1),
            )
          )
        ),
      );
      TCollection(hdl, converters)
    | _ -> invariant_violation("Store context must be specified.")
    }
  }

  private fun nativeMapReduceImpl<K2: frozen & Orderable, V2: frozen>(
    mapper: Mapper<K, V, K2, V2>,
    reducer: SKStore.EReducer<SKStore.File, SKStore.File>,
  ): TCollection<K2, V2> {
    getContext() match {
    | Some(context) ->
      collectionId = `collection_${SKStore.genSym(0)}`;
      dirName = this.hdl.dirName.sub(collectionId);
      converters = mapper.converters();
      hdl = this.hdl.mapReduce(
        kNOTYPE_KEY,
        kNOTYPE_VALUE,
        context,
        dirName,
        SKStoreMapper(mapper, this.converters).map,
        reducer,
      );
      TCollection(hdl, converters)
    | _ -> invariant_violation("Store context must be specified.")
    }
  }

  private fun eReducer(
    reducer: String,
    value: SKStore.File ~> Int,
    create: Int ~> SKStore.File,
  ): SKStore.EReducer<SKStore.File, SKStore.File> {
    reducer match {
    | "sum" -> SKStore.sumReducer_(value, create, kNOTYPE_VALUE)
    | "min" -> SKStore.minReducer_(value, create, kNOTYPE_VALUE)
    | "max" -> SKStore.maxReducer_(value, create, kNOTYPE_VALUE)
    | "count" -> SKStore.countReducer_(value, create, kNOTYPE_VALUE)
    | _ -> throw SKStore.Error("Unrecognized native reducer: " + reducer)
    };
  }
}

class LazyCollection<K: frozen & Orderable, V: frozen>(
  private hdl: SKStore.LHandle<SKStore.Key, SKStore.File>,
  converters: ConverterPair<K, V>,
) {
  //
  static fun forName<K: frozen & Orderable, V: frozen>(
    name: String,
    converters: ConverterPair<K, V>,
  ): LazyCollection<K, V> {
    hdl = SKStore.LHandle(
      kNOTYPE_KEY,
      kNOTYPE_VALUE,
      SKStore.DirName::create(name),
    );
    LazyCollection(hdl, converters)
  }

  fun getId(): String {
    this.hdl.dirName.toString();
  }

  /**
   * Get (and potentially compute) all values mapped to by some key of a lazy reactive
   * collection.
   */
  fun getArray(key: K): Array<V> {
    getContext() match {
    | Some(context) ->
      this.hdl.getArray(context, this.converters.key.toKey(key)).map(
        this.converters.value.fromFile,
      )
    | _ -> invariant_violation("Store context must be specified.")
    }
  }

  /**
   * Get (and potentially compute) a value of a lazy reactive collection.
   * @throws {Error} when either zero or multiple such values exist
   */
  fun getUnique(key: K): V {
    getContext() match {
    | Some(context) ->
      this.converters.value.fromFile(
        this.hdl.get(context, this.converters.key.toKey(key)),
      )
    | _ -> invariant_violation("Store context must be specified.")
    }
  }
}

private fun resourceId(
  context: readonly SKStore.Context,
  dir: SKStore.EagerDir,
): ?ResourceDef {
  dir.creator match {
  | Some(arrow) ->
    if (isResourceDir(arrow.parentName)) {
      Some(ResourceDef::keyType(arrow.key))
    } else {
      context.unsafeMaybeGetEagerDir(arrow.parentName) match {
      | Some(sdir) -> resourceId(context, sdir)
      | _ -> None()
      }
    }
  | _ -> None()
  }
}

private fun sessionId(
  context: readonly SKStore.Context,
  dir: SKStore.EagerDir,
): ?String {
  resourceId(context, dir).map(def -> toResourceId(def.name, def.params))
}

private fun isResourceDir(dirName: SKStore.DirName): Bool {
  dirName == kResourceStatusDir
}

class CollectionWriter(dirName: SKStore.DirName) {
  //
  fun getId(): String {
    this.dirName.toString()
  }

  fun update(
    values: Array<(SKStore.Key, Array<SKStore.File>)>,
    isInit: Bool,
    executor: Executor,
  ): Result<void, .Exception> {
    performOnTransaction(this.dirName, (root, context) ~>
      this.update_(root, context, values, isInit, executor)
    )
  }

  fun error(error: IError): Result<void, .Exception> {
    performOnTransaction(this.dirName, (_root, context) ~> {
      _ = this.updateStatus(context, status ~> status.err(error));
      updateContext(context);
    })
  }

  fun initialized(error: ?IError): Result<void, .Exception> {
    performOnTransaction(
      this.dirName,
      (_root, context) ~> {
        optResource = this.updateStatus(context, status ~> status.init(error));
        context.update();
        checkInitialization(context, optResource);
        checkGarbage(context);
      },
      true,
    )
  }

  fun status(context: mutable SKStore.Context, status: Status<IError>): void {
    context.maybeGetEagerDir(this.dirName) match {
    | Some(dir) ->
      dirname = sessionId(context, dir) match {
      | Some(sId) -> kResourceSessionDir.sub(sId).sub("status")
      | _ -> kSessionDir.sub("status")
      };
      shdl = SKStore.EHandle(
        SKStore.DirName::keyType,
        StatusFile::type,
        dirname,
      );
      shdl.writeArray(
        context,
        this.dirName,
        Array[StatusFile(status.unTyped())],
      )
    | _ -> void
    };
  }

  fun updateStatus(
    context: mutable SKStore.Context,
    update: Status<IError> ~> Status<IError>,
  ): ?ResourceDef {
    context.maybeGetEagerDir(this.dirName) match {
    | Some(dir) ->
      optResource = resourceId(context, dir);
      dirname = optResource match {
      | Some(def) ->
        kResourceSessionDir
          .sub(toResourceId(def.name, def.params))
          .sub("status")
      | _ -> kSessionDir.sub("status")
      };
      shdl = SKStore.EHandle(
        SKStore.DirName::keyType,
        StatusFile::type,
        dirname,
      );
      status = update(shdl.get(context, this.dirName).status);
      shdl.writeArray(
        context,
        this.dirName,
        Array[StatusFile(status.unTyped())],
      );
      optResource
    | _ -> None()
    };
  }

  private fun update_(
    root: mutable SKStore.Context,
    context: mutable SKStore.Context,
    values: Array<(SKStore.Key, Array<SKStore.File>)>,
    isInit: Bool,
    executor: Executor,
  ): void {
    context.maybeGetEagerDir(this.dirName) match {
    | None() -> return void
    | _ -> void
    };
    _ = this.updateStatus(context, status ~> status.ok());
    writeInCollection(root, context, this.dirName, values, executor, isInit)
  }
}

value class GetResult<T>(values: T, errors: Array<IError>)

fun getAll(
  context: mutable SKStore.Context,
  resourceName: String,
  params: Parameters,
): GetResult<Values> {
  graphHdl = SKStore.EHandle(
    ResourceDef::keyType,
    ResourceInfo::type,
    kResourceCollectionsDir,
  );
  resourceID = ResourceDef(resourceName, params);
  resource = graphHdl.get(context, resourceID);
  pushContext(context);
  values = Values(
    resource.collection.getAll(),
    `${resource.session}/${context.getTick()}`,
  );
  popContext();
  resource.getResult(context, values);
}

fun resourceSnapshot(
  context: mutable SKStore.Context,
  resourceName: String,
  params: Parameters,
): Array<Entry> {
  graphHdl = SKStore.EHandle(
    ResourceDef::keyType,
    ResourceInfo::type,
    kResourceCollectionsDir,
  );
  resourceID = ResourceDef(resourceName, params);
  resource = graphHdl.get(context, resourceID);
  pushContext(context);
  entries = resource.collection.getAll();
  popContext();
  entries
}

fun getForKey(
  context: mutable SKStore.Context,
  resourceName: String,
  params: Parameters,
  key: SKStore.Key,
): GetResult<Array<SKStore.File>> {
  graphHdl = SKStore.EHandle(
    ResourceDef::keyType,
    ResourceInfo::type,
    kResourceCollectionsDir,
  );
  resourceID = ResourceDef(resourceName, params);
  resource = graphHdl.get(context, resourceID);
  pushContext(context);
  values = resource.collection.lookupValues(key);
  popContext();
  resource.getResult(context, values);
}

fun resourceSnapshotLookup(
  context: mutable SKStore.Context,
  resourceName: String,
  params: Parameters,
  key: String,
): Entry {
  graphHdl = SKStore.EHandle(
    ResourceDef::keyType,
    ResourceInfo::type,
    kResourceCollectionsDir,
  );
  resourceID = ResourceDef(resourceName, params);
  resource = graphHdl.get(context, resourceID);
  pushContext(context);
  entry = resource.collection.lookup(key);
  popContext();
  entry
}

fun destroyReactiveResource(
  context: mutable SKStore.Context,
  sid: SKStore.SID,
): void {
  context
    .getPersistent(`subscription.${sid}`)
    .map(SKStore.IntFile::type) match {
  | Some(subId) ->
    session = subId.value;
    context.getSession(session).each(sub -> {
      close = sub.cmd match {
      | SKStore.NWatch(_, _, _, close, _) -> close
      | _ -> invariant_violation("Not manage session kind")
      };
      context.removePersistent(`subscription.${sid}`);
      close();
      context.unsubscribe(session);
    })
  | _ -> void
  };
  resourceHdl = SKStore.EHandle(
    SKStore.SID::keyType,
    ResourceDef::type,
    kResourceSessionDir,
  );
  resourceHdl.writeArray(context, sid, Array[]);
}

fun closeReactiveResource(
  context: mutable SKStore.Context,
  identifier: String,
  update: Bool = true,
): void {
  context
    .getPersistent(`subscription.${identifier}`)
    .map(SKStore.IntFile::type) match {
  | Some(subId) -> unsubscribe(context, subId.value, update)
  | _ ->
    garbageHdl = SKStore.EHandle(
      SKStore.SID::keyType,
      SKStore.IntFile::type,
      kResourceGarbageDir,
    );
    sid = SKStore.SID(identifier);
    if (garbageHdl.maybeGet(context, sid).isSome()) return void;
    time = Time.time_ms();
    garbageHdl.writeArray(context, sid, Array[SKStore.IntFile(time)]);
    if (update) updateContext(context)
  };
}

fun subscribe(
  context: mutable SKStore.Context,
  identifier: String,
  notifier: Notifier,
  optWatermark: ?String,
  optSession: ?Int = None(),
): Int {
  garbageHdl = SKStore.EHandle(
    SKStore.SID::keyType,
    SKStore.IntFile::type,
    kResourceGarbageDir,
  );
  sid = SKStore.SID(identifier);
  session = optSession.default(SKStore.genSym(0));
  resourceHdl = SKStore.EHandle(
    SKStore.SID::keyType,
    ResourceDef::type,
    kResourceSessionDir,
  );
  resourcesCollectionsHdl = SKStore.EHandle(
    ResourceDef::keyType,
    ResourceInfo::type,
    kResourceCollectionsDir,
  );
  subId = `subscription.${identifier}`;
  if (context.getPersistent(subId).isSome()) {
    throw ResourceInstanceInUse(identifier)
  };
  resourceHdl.maybeGet(context, sid) match {
  | Some(definition) ->
    info = resourcesCollectionsHdl.get(context, definition);
    start = `${info.session}/`;
    from = optWatermark match {
    | Some(watermark) if (watermark.startsWith(start)) ->
      watermark.stripPrefix(start).toInt()
    | _ -> 0
    };
    notifier.subscribed();
    pushContext(context);
    info.collection.subscribe(
      identifier,
      session,
      SKStore.Tick(from),
      (values, tick, update) ~> {
        notifier.notify(values, `${info.session}/${tick}`, update)
      },
      notifier.close,
    );
    popContext();
    context.setPersistent(subId, SKStore.IntFile(session));
    if (garbageHdl.maybeGet(context, sid).isSome()) {
      garbageHdl.writeArray(context, sid, Array[]);
      context.update();
    };
    checkGarbage(context);
    session
  | _ -> throw UnknownCollectionError(identifier)
  }
}

fun unsubscribe(
  context: mutable SKStore.Context,
  session: Int,
  update: Bool = true,
): void {
  context.getSession(session).each(sub -> {
    (identifier, close) = sub.cmd match {
    | SKStore.NWatch(identifier, _, _, close, _) -> (identifier, close)
    | _ -> invariant_violation("Not manage session kind")
    };
    context.removePersistent(`subscription.${identifier}`);
    close();
    context.unsubscribe(session);
    closeReactiveResource(context, identifier, update);
  });
}

// WRITES

fun put(
  context: mutable SKStore.Context,
  collection: String,
  key: SKStore.Key,
  value: Array<SKStore.File>,
): void {
  chdl = SKStore.EHandle(
    kNOTYPE_KEY,
    kNOTYPE_VALUE,
    SKStore.DirName::create(`/${collection}/`),
  );
  chdl.writeArray(context, key, value);
  updateContext(context);
}

private fun writeInCollection(
  root: mutable SKStore.Context,
  main: mutable SKStore.Context,
  dirName: SKStore.DirName,
  values: Array<(SKStore.Key, Array<SKStore.File>)>,
  executor: Executor,
  isInit: Bool = false,
): void {
  chdl = SKStore.EHandle(kNOTYPE_KEY, kNOTYPE_VALUE, dirName);
  transaction = checkTransaction(main);
  keys = if (isInit) {
    transaction.context.maybeGetEagerDir(dirName) match {
    | Some(dir) -> dir.keys()
    | _ -> SortedSet<SKStore.Key>[]
    }
  } else {
    SortedSet<SKStore.Key>[]
  };
  toAdd = mutable Vector[];
  values.each(e -> {
    toAdd.push((e.i0, e.i1));
    !keys = keys.remove(e.i0);
  });
  fadded = toAdd.toArray();
  fremoved = keys;
  commit = (ctx) ~> {
    fadded.each(added -> chdl.writeArray(ctx, added.i0, added.i1));
    fremoved.each(key -> chdl.writeArray(ctx, key, Array[]));
  };
  commit(transaction.context);
  // Do not check garbage collection to prevent closing resources
  transaction.context.update();
  finalizeTransaction(root, main, transaction, commit, executor);
}

fun update(
  context: mutable SKStore.Context,
  collection: String,
  values: Array<(SKStore.Key, Array<SKStore.File>)>,
  executor: Executor,
): void {
  writeInCollection(
    context,
    context,
    SKStore.DirName::create(`/${collection}/`),
    values,
    executor,
  )
}

fun delete(
  context: mutable SKStore.Context,
  collection: String,
  key: SKJSON.CJSON,
): void {
  chdl = SKStore.EHandle(
    JSONID::keyType,
    JSONFile::type,
    SKStore.DirName::create(`/${collection}/`),
  );
  chdl.writeArray(context, JSONID(key), Array[]);
  updateContext(context);
}

fun createReactiveResource(
  context: mutable SKStore.Context,
  identifier: String,
  resource: String,
  params: Parameters,
  executor: Executor,
): ResourceInfo {
  resourceHdl = SKStore.EHandle(
    SKStore.SID::keyType,
    ResourceDef::type,
    kResourceSessionDir,
  );
  graphHdl = SKStore.EHandle(
    ResourceDef::keyType,
    ResourceInfo::type,
    kResourceCollectionsDir,
  );
  key = SKStore.SID(identifier);
  resourceHdl.maybeGet(context, key) match {
  | Some _ -> throw ExistingResourceException()
  | _ -> void
  };
  definition = ResourceDef(resource, params);
  resourceHdl.writeArray(context, key, Array[definition]);
  context.update();
  checkResourceInstanceSubcriptions(context, definition, identifier, executor);
  checkGarbage(context);
  graphHdl.get(context, definition);
}

fun getReactiveResource(
  context: mutable SKStore.Context,
  identifier: String,
): ResourceInfo {
  resourceHdl = SKStore.EHandle(
    SKStore.SID::keyType,
    ResourceDef::type,
    kResourceSessionDir,
  );
  graphHdl = SKStore.EHandle(
    ResourceDef::keyType,
    ResourceInfo::type,
    kResourceCollectionsDir,
  );
  key = SKStore.SID(identifier);
  definition = resourceHdl.get(context, key);
  graphHdl.get(context, definition);
}

fun getResourceBuilder(
  context: mutable SKStore.Context,
  name: String,
): ResourceBuilder {
  sessionHdl = SKStore.EHandle(
    SKStore.UnitID::keyType,
    ServiceDefinition::type,
    kSessionDir,
  );
  (sessionHdl.maybeGet(context, SKStore.UnitID::singleton) match {
  | Some(def) -> def.service.resourceBuilders().maybeGet(name)
  | _ -> None()
  }) match {
  | Some(builder) -> builder
  | _ -> throw SKStore.Error(`Unable to find '${name}' resource.`)
  }
}

fun getResourceBuilderForInstance(
  context: mutable SKStore.Context,
  instance: String,
): ResourceBuilder {
  resourceHdl = SKStore.EHandle(
    SKStore.SID::keyType,
    ResourceDef::type,
    kResourceSessionDir,
  );
  sid = SKStore.SID(instance);
  resourceHdl.maybeGet(context, sid) match {
  | Some(definition) -> getResourceBuilder(context, definition.name)
  | _ -> throw UnknownCollectionError(instance)
  }
}

fun getInputData(
  context: mutable SKStore.Context,
  input: String,
): (Collection, Data) {
  sessionHdl = SKStore.EHandle(
    SKStore.UnitID::keyType,
    ServiceDefinition::type,
    kSessionDir,
  );
  serviceHdl = SKStore.EHandle(
    SKStore.SID::keyType,
    ServiceFile::type,
    kGraphDir,
  );
  (sessionHdl.maybeGet(context, SKStore.UnitID::singleton) match {
  | Some(def) ->
    (
      def.service.initialData().maybeGet(input),
      serviceHdl.maybeGet(context, SKStore.SID(def.runId)) match {
      | Some(service) -> service.inputs.maybeGet(input)
      | _ -> None()
      },
    ) match {
    | (Some(d), Some(c)) -> Some((c, d))
    | _ -> None()
    }
  | _ -> None()
  }) match {
  | Some(data) -> data
  | _ -> throw SKStore.Error(`Unable to find '${input}' input.`)
  }
}

fun checkGarbage(context: mutable SKStore.Context): void {
  garbageHdl = SKStore.EHandle(
    SKStore.SID::keyType,
    SKStore.IntFile::type,
    kResourceGarbageDir,
  );
  resourceHdl = SKStore.EHandle(
    SKStore.SID::keyType,
    ResourceDef::type,
    kResourceSessionDir,
  );
  time = Time.time_ms();
  destroyed = mutable Vector[];
  garbageHdl.items(context).each(kf -> {
    kf.i1.next().each(f -> {
      suppressed = f.value;
      if (time - suppressed > kGarbageMillis) {
        key = kf.i0;
        destroyed.push(key);
        resourceHdl.writeArray(context, key, Array[]);
      }
    })
  });
  destroyed.each(key -> garbageHdl.writeArray(context, key, Array[]));
  if (!destroyed.isEmpty()) context.update();
}

fun updateContext(context: mutable SKStore.Context): void {
  context.update();
  checkGarbage(context);
}

@no_inline
fun concreteByName<T: IO.Serializable>(name: String): Concrete<T> {
  name match {
  | "Int" -> IO.unsafeConcreteCast(Int)
  | "Float" -> IO.unsafeConcreteCast(Float)
  | "SkipRuntime.SEntry" -> IO.unsafeConcreteCast(SEntry)
  | _ -> invariant_violation(`Unknown class name '${name}'`)
  };
}

module end;
