module alias SR = SkipRuntime;
module SumService;

const kSTRING_INT_TYPES: SR.ConverterPair<String, Int> = SR.ConverterPair(
  SR.StringKeyConverter(),
  SR.IntValueConverter(),
);

const kSTRING_INDEXED_TYPES: SR.ConverterPair<
  String,
  Indexed,
> = SR.ConverterPair(
  SR.StringKeyConverter(),
  SR.FileValueConverter(Indexed::type),
);

class Inputs{
  input1: SR.TCollection<String, Int>,
  input2: SR.TCollection<String, Int>,
} extends SR.Collections {
  fun maybeGet(name: String): ?SR.Collection {
    name match {
    | "input1" -> Some(this.input1)
    | "input2" -> Some(this.input2)
    | _ -> None()
    }
  }

  fun each(fn: (String, SR.Collection) -> void): void {
    fn("input1", this.input1);
    fn("input2", this.input2);
  }
}

fun inputsFromJson(jsonString: String): Array<SR.Entry> {
  SKJSON.expectArray(SKJSON.decode(jsonString, x -> x)).map(v -> {
    e = SKJSON.expectArray(v);
    SR.TEntry::create(
      SKJSON.asString(e[0]),
      SKJSON.expectArray(e[1]).map(SKJSON.asInt),
    )
  })
}

class StringIntToJsonSnapshot() extends SR.Snapshot {
  //
  fun snapshot(entries: Array<SR.Entry>): String {
    SKJSON.CJArray(
      entries.map(entry -> {
        tentry = SR.castEntry<String, Int>(entry);
        SKJSON.CJArray(
          Array[
            SKJSON.CJString(tentry.key()),
            SKJSON.CJArray(tentry.values.map(v -> SKJSON.CJInt(v))),
          ],
        )
      }),
    ).prettyPrint()
  }

  fun snapshotLookup(entry: SR.Entry): String {
    tentry = SR.castEntry<String, Int>(entry);
    SKJSON.CJArray(
      Array[
        SKJSON.CJString(tentry.key()),
        SKJSON.CJArray(tentry.values.map(v -> SKJSON.CJInt(v))),
      ],
    ).prettyPrint()
  }
}

class Indexed(index: Int, value: Int) extends SKStore.File uses Orderable

class AddIndex(
  private index: Int,
) extends SR.Mapper<String, Int, String, Indexed> {
  fun mapEntry(
    key: String,
    values: mutable SKStore.NonEmptyIterator<Int>,
  ): mutable Iterator<(String, Indexed)> {
    Array[(key, Indexed(this.index, values.first))].iterator();
  }

  fun converters(): SR.ConverterPair<String, Indexed> {
    kSTRING_INDEXED_TYPES
  }
}

class Plus() extends SR.Mapper<String, Int, String, Int> {
  fun mapEntry(
    key: String,
    values: mutable SKStore.NonEmptyIterator<Int>,
  ): mutable Iterator<(String, Int)> {
    val = values.values().reduce((p, c) ~> p + c, 0);
    Array[(key, val)].iterator();
  }

  fun converters(): SR.ConverterPair<String, Int> {
    kSTRING_INT_TYPES
  }
}

class Minus() extends SR.Mapper<String, Indexed, String, Int> {
  fun mapEntry(
    key: String,
    values: mutable SKStore.NonEmptyIterator<Indexed>,
  ): mutable Iterator<(String, Int)> {
    acc = (p: ?Int, c: Indexed) ~> {
      p match {
      | Some(v) -> Some(v - c.value)
      | _ -> Some(c.value)
      }
    };
    res = values.values().collect(Array).sorted().reduce(acc, None()) match {
    | Some(val) -> Array[(key, val)]
    | _ -> Array[]
    };
    res.iterator();
  }

  fun converters(): SR.ConverterPair<String, Int> {
    kSTRING_INT_TYPES
  }
}

fun fromCollections(collections: SR.Collections): Inputs {
  Inputs{
    input1 => collections.get("input1").unsafeCast(kSTRING_INT_TYPES),
    input2 => collections.get("input2").unsafeCast(kSTRING_INT_TYPES),
  }
}

class Add() extends SR.TResource<String, Int, Inputs> {
  fun instantiate(cs: Inputs): SR.TCollection<String, Int> {
    cs.input1.merge(Array[cs.input2]).map(Plus())
  }

  fun fromCollections(collections: SR.Collections): Inputs {
    fromCollections(collections)
  }
}

class Sub() extends SR.TResource<String, Int, Inputs> {
  fun instantiate(cs: Inputs): SR.TCollection<String, Int> {
    cs.input1
      .map(AddIndex(0))
      .merge(Array[cs.input2.map(AddIndex(1))])
      .map(Minus())
  }

  fun fromCollections(collections: SR.Collections): Inputs {
    fromCollections(collections)
  }
}

class Service() extends SR.TService<Inputs, Inputs> uses SR.WithServiceData {
  const data: SR.ServiceData = SR.ServiceData{
    initialData => Map[
      "input1" => SR.InitialData(Array[], kSTRING_INT_TYPES, inputsFromJson),
      "input2" => SR.InitialData(Array[], kSTRING_INT_TYPES, inputsFromJson),
    ],
    resourceBuilders => Map[
      "add" => SR.NoParamsBuilder(Add(), StringIntToJsonSnapshot()),
      "sub" => SR.NoParamsBuilder(Sub(), StringIntToJsonSnapshot()),
    ],
    externalServices => Map[],
  };

  fun createTypedGraph(ics: Inputs): Inputs {
    ics
  }

  fun fromCollections(inputs: SR.Collections): Inputs {
    fromCollections(inputs)
  }
}

@export("Skip_service")
fun getService(): SR.Service {
  Service()
}

module end;
