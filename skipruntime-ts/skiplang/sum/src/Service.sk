module alias SR = SkipRuntime;
module SumService;

const kSTRING_INT_TYPES: SR.ConverterPair<String, Int> = SR.ConverterPair(
  SR.StringKeyConverter(),
  SR.IntValueConverter(),
);

const kSTRING_INDEXED_TYPES: SR.ConverterPair<
  String,
  Indexed,
> = SR.ConverterPair(
  SR.StringKeyConverter(),
  SR.FileValueConverter(Indexed::type),
);

class Inputs{
  input1: SR.Collection<String, Int>,
  input2: SR.Collection<String, Int>,
} extends SR.Collections

class Indexed(index: Int, value: Int) extends SKStore.File uses Orderable

class AddIndex(
  private index: Int,
) extends SR.Mapper<String, Int, String, Indexed> {
  fun mapEntry(
    key: String,
    values: mutable SKStore.NonEmptyIterator<Int>,
  ): mutable Iterator<(String, Indexed)> {
    Array[(key, Indexed(this.index, values.first))].iterator();
  }

  fun converters(): SR.ConverterPair<String, Indexed> {
    kSTRING_INDEXED_TYPES
  }
}

class Plus() extends SR.Mapper<String, Int, String, Int> {
  fun mapEntry(
    key: String,
    values: mutable SKStore.NonEmptyIterator<Int>,
  ): mutable Iterator<(String, Int)> {
    val = values.collect(Array).reduce((p, c) ~> p + c, 0);
    Array[(key, val)].iterator();
  }

  fun converters(): SR.ConverterPair<String, Int> {
    kSTRING_INT_TYPES
  }
}

class Minus() extends SR.Mapper<String, Indexed, String, Int> {
  fun mapEntry(
    key: String,
    values: mutable SKStore.NonEmptyIterator<Indexed>,
  ): mutable Iterator<(String, Int)> {
    acc = (p: ?Int, c: Indexed) ~> {
      p match {
      | Some(v) -> Some(v - c.value)
      | _ -> Some(c.value)
      }
    };
    res = values.collect(Array).sorted().reduce(acc, None()) match {
    | Some(val) -> Array[(key, val)]
    | _ -> Array[]
    };
    res.iterator();
  }

  fun converters(): SR.ConverterPair<String, Int> {
    kSTRING_INT_TYPES
  }
}

fun fromMap(
  map: Map<String, SR.Collection<SKStore.Key, SKStore.File>>,
): Inputs {
  Inputs{
    input1 => map.get("input1").unsafeCast(kSTRING_INT_TYPES),
    input2 => map.get("input2").unsafeCast(kSTRING_INT_TYPES),
  }
}

class Add() extends SR.TResource<String, Int, Inputs> {
  fun instantiate(cs: Inputs): SR.Collection<String, Int> {
    cs.input1.merge(Array[cs.input2]).map(Plus())
  }

  fun fromMap(
    map: Map<String, SR.Collection<SKStore.Key, SKStore.File>>,
  ): Inputs {
    fromMap(map)
  }
}

class Sub() extends SR.TResource<String, Int, Inputs> {
  fun instantiate(cs: Inputs): SR.Collection<String, Int> {
    cs.input1
      .map(AddIndex(0))
      .merge(Array[cs.input2.map(AddIndex(1))])
      .map(Minus())
  }

  fun fromMap(
    map: Map<String, SR.Collection<SKStore.Key, SKStore.File>>,
  ): Inputs {
    fromMap(map)
  }
}

class Service() extends SR.TService<Inputs, Inputs> uses SR.WithServiceData {
  const data: SR.ServiceData = SR.ServiceData{
    initialData => Map["input1" => SR.EmptyData(), "input2" => SR.EmptyData()],
    resourceBuilders => Map[
      "add" => SR.NoParamsBuilder(Add()),
      "sub" => SR.NoParamsBuilder(Sub()),
    ],
    externalServices => Map[],
  };

  fun createTypedGraph(ics: Inputs): Inputs {
    ics
  }

  fun fromMap(
    map: Map<String, SR.Collection<SKStore.Key, SKStore.File>>,
  ): Inputs {
    fromMap(map)
  }

  fun toMap(
    inputs: Inputs,
  ): Map<String, SR.Collection<SKStore.Key, SKStore.File>> {
    Map[
      "input1" => inputs.input1.unTyped(),
      "input2" => inputs.input2.unTyped(),
    ]
  }
}

@service
fun getService(): SR.Service {
  Service()
}

module end;
