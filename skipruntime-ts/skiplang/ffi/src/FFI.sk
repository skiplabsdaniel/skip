module SkipRuntime;

type JSONMapper = Mapper<
  SKJSON.CJSON,
  SKJSON.CJSON,
  SKJSON.CJSON,
  SKJSON.CJSON,
>;

fun intToJSON(value: Int): SKJSON.CJSON {
  SKJSON.CJInt(value)
}

fun jsonFromFile(value: SKStore.File): SKJSON.CJSON {
  JSONFile::type(value).json
}

fun jsonFromKey(key: SKStore.Key): SKJSON.CJSON {
  JSONID::keyType(key).json
}

fun jsonFromError(error: IError): SKJSON.CJSON {
  (error as JSONError _).error
}

@cpp_extern("SkipRuntime_getErrorHdl")
@debug
native fun getErrorHdl(exn: .Exception): Float;

/************  NonEmptyIterator ****************/

@export("SkipRuntime_NonEmptyIterator__next")
fun nextOfNonEmptyIterator(
  values: mutable SKStore.NonEmptyIterator<SKJSON.CJSON>,
): ?SKJSON.CJSON {
  values.next()
}

/************  Mapper ****************/

@cpp_extern("SkipRuntime_Mapper__mapEntry")
@debug
native fun mapEntryOfMapper(
  mapper: UInt32,
  key: SKJSON.CJSON,
  values: mutable SKStore.NonEmptyIterator<SKJSON.CJSON>,
): SKJSON.CJArray;

@cpp_extern("SkipRuntime_deleteMapper")
@debug
native fun deleteMapper(mapper: UInt32): void;

@export("SkipRuntime_createMapper")
fun createMapper(mapper: UInt32): ExternMapper {
  ExternMapper(SKStore.ExternalPointer::create(mapper, deleteMapper))
}

class ExternMapper(
  eptr: SKStore.ExternalPointer,
) extends Mapper<SKJSON.CJSON, SKJSON.CJSON, SKJSON.CJSON, SKJSON.CJSON> {
  fun mapEntry(
    key: SKJSON.CJSON,
    values: mutable SKStore.NonEmptyIterator<SKJSON.CJSON>,
  ): mutable Iterator<(SKJSON.CJSON, SKJSON.CJSON)> {
    mapEntryOfMapper(this.eptr.value, key, values) match {
    | SKJSON.CJArray(vals) ->
      vals
        .map(e ->
          e match {
          | SKJSON.CJArray(av) ->
            optKey = av.maybeGet(0);
            optVal = av.maybeGet(1);
            (optKey, optVal) match {
            | (Some(rkey), Some(rval)) -> (rkey, rval)
            | _ -> invariant_violation("Invalid entry.")
            }
          | _ -> invariant_violation("Invalid entry.")
          }
        )
        .iterator()
    }
  }

  fun converters(): ConverterPair<SKJSON.CJSON, SKJSON.CJSON> {
    kJSON_CONVERTERS
  }
}

/************  LazyCompute ****************/

@cpp_extern("SkipRuntime_LazyCompute__compute")
@debug
native fun computeOfLazyCompute(
  lazyCompute: UInt32,
  self: String,
  key: SKJSON.CJSON,
): SKJSON.CJSON;

@cpp_extern("SkipRuntime_deleteLazyCompute")
@debug
native fun deleteLazyCompute(lazyCompute: UInt32): void;

@export("SkipRuntime_createLazyCompute")
fun createLazyCompute(lazyCompute: UInt32): ExternLazyCompute {
  ExternLazyCompute(
    SKStore.ExternalPointer::create(lazyCompute, deleteLazyCompute),
  )
}

class ExternLazyCompute(
  eptr: SKStore.ExternalPointer,
) extends LazyCompute<SKJSON.CJSON, SKJSON.CJSON> {
  fun compute(
    self: LazyCollection<SKJSON.CJSON, SKJSON.CJSON>,
    key: SKJSON.CJSON,
  ): Array<SKJSON.CJSON> {
    computeOfLazyCompute(this.eptr.value, self.getId(), key) match {
    | SKJSON.CJArray(value) -> value
    | _ -> invariant_violation("Invalid computed value.")
    }
  }
}

/************  ExternalService ****************/

@cpp_extern("SkipRuntime_ExternalService__subscribe")
@debug
native fun subscribeOfExternalService(
  externalSupplier: UInt32,
  collection: String,
  instance: String,
  resource: String,
  params: SKJSON.CJSON,
): void;

@cpp_extern("SkipRuntime_ExternalService__unsubscribe")
@debug
native fun unsubscribeOfExternalService(
  externalSupplier: UInt32,
  instance: String,
): void;

@cpp_extern("SkipRuntime_ExternalService__shutdown")
@debug
native fun shutdownOfExternalService(externalSupplier: UInt32): Float;

@cpp_extern("SkipRuntime_deleteExternalService")
@debug
native fun deleteExternalService(externalSupplier: UInt32): void;

@export("SkipRuntime_createExternalService")
fun createExternalService(externalSupplier: UInt32): ExternExternalService {
  ExternExternalService(
    SKStore.ExternalPointer::create(externalSupplier, deleteExternalService),
  )
}

class ExternExternalService(
  eptr: SKStore.ExternalPointer,
) extends ExternalService {
  fun subscribe(
    instance: String,
    writer: CollectionWriter,
    resource: String,
    params: Parameters,
  ): void {
    subscribeOfExternalService(
      this.eptr.value,
      writer.getId(),
      instance,
      resource,
      (params as JSONParams _).json,
    )
  }

  fun unsubscribe(instance: String): void {
    unsubscribeOfExternalService(this.eptr.value, instance)
  }

  fun shutdown(): Float {
    shutdownOfExternalService(this.eptr.value)
  }
}

/************  CollectionWriter ****************/

@export("SkipRuntime_CollectionWriter__update")
fun updateOfCollectionWriter(
  collection: String,
  values: SKJSON.CJArray,
  isInit: Int32,
  executor: Executor,
): Float {
  writer = CollectionWriter(SKStore.DirName::create(collection));
  writer.update(
    values match {
    | SKJSON.CJArray(vs) ->
      vs.map(v -> {
        e = SKJSON.expectArray(v);
        (JSONID(e[0]), SKJSON.expectArray(e[1]).map(v -> JSONFile(v)))
      })
    },
    isInit != 0,
    executor,
  ) match {
  | Success _ -> 0.0
  | Failure(err) -> getErrorHdl(err)
  };
}

@export("SkipRuntime_CollectionWriter__initialized")
fun initializedOfCollectionWriter(
  collection: String,
  error: SKJSON.CJSON,
): Float {
  writer = CollectionWriter(SKStore.DirName::create(collection));
  writer.initialized(
    error match {
    | SKJSON.CJNull() -> None()
    | _ -> Some(JSONError(error))
    },
  ) match {
  | Success _ -> 0.0
  | Failure(err) -> getErrorHdl(err)
  };
}

@export("SkipRuntime_CollectionWriter__error")
fun errorOfCollectionWriter(collection: String, error: SKJSON.CJSON): Float {
  writer = CollectionWriter(SKStore.DirName::create(collection));
  writer.error(JSONError(error)) match {
  | Success _ -> 0.0
  | Failure(err) -> getErrorHdl(err)
  };
}

/************  Resource ****************/

@cpp_extern("SkipRuntime_Resource__instantiate")
@debug
native fun instantiateOfResource(
  resource: UInt32,
  collections: SKJSON.CJObject,
): String;

@cpp_extern("SkipRuntime_deleteResource")
@debug
native fun deleteResource(resource: UInt32): void;

@export("SkipRuntime_createResource")
fun createResource(resource: UInt32): ExternResource {
  ExternResource(SKStore.ExternalPointer::create(resource, deleteResource))
}

class ExternResource(eptr: SKStore.ExternalPointer) extends Resource {
  fun materialize(collections: Collections): Collection {
    collectionName = instantiateOfResource(
      this.eptr.value,
      collectionsByName(collections),
    );
    collectionForName(collectionName)
  }
}

/************  ResourceBuilder ****************/

@cpp_extern("SkipRuntime_ResourceBuilder__build")
@debug
native fun buildOfResourceBuilder(
  builder: UInt32,
  params: SKJSON.CJSON,
): Resource;

@cpp_extern("SkipRuntime_deleteResourceBuilder")
@debug
native fun deleteResourceBuilder(resourceBuilder: UInt32): void;

@export("SkipRuntime_createResourceBuilder")
fun createResourceBuilder(resourceBuilder: UInt32): ExternResourceBuilder {
  ExternResourceBuilder(
    SKStore.ExternalPointer::create(resourceBuilder, deleteResourceBuilder),
  )
}

class ExternResourceBuilder(
  eptr: SKStore.ExternalPointer,
) extends TResourceBuilder<SKJSON.CJSON> uses SKJSONParameters {
  //
  fun build(params: SKJSON.CJSON): Resource {
    buildOfResourceBuilder(this.eptr.value, params)
  }

  fun snapshot(): Snapshot {
    UnusedSnapshot()
  }
}

/************  Executor ****************/

@cpp_extern("SkipRuntime_Executor__resolve")
@debug
native fun resolveOfExecutor(executor: UInt32): void;

@cpp_extern("SkipRuntime_Executor__reject")
@debug
native fun rejectOfExecutor(executor: UInt32, errorHandle: Float): void;

@cpp_extern("SkipRuntime_deleteExecutor")
@debug
native fun deleteExecutor(mapper: UInt32): void;

@export("SkipRuntime_createExecutor")
fun createExecutor(executor: UInt32): ExternExecutor {
  ExternExecutor(SKStore.ExternalPointer::create(executor, deleteExecutor))
}

class ExternExecutor(eptr: SKStore.ExternalPointer) extends Executor {
  fun resolve(): void {
    resolveOfExecutor(this.eptr.value)
  }

  fun reject(exc: .Exception): void {
    rejectOfExecutor(this.eptr.value, getErrorHdl(exc))
  }
}

/************  Service ****************/

@export("SkipRuntime_createService")
fun createService(
  service: UInt32,
  jsInitialData: SKJSON.CJObject,
  resourceBuilders: mutable Map<String, ResourceBuilder>,
  externalServices: mutable Map<String, ExternalService>,
): ExternService {
  initialData = mutable Map[];
  jsInitialData match {
  | SKJSON.CJObject(fields) ->
    for (fieldName => field in fields) {
      initialData.add(
        fieldName,
        InitialData(
          entriesFromJson(field),
          kJSON_CONVERTERS,
          entriesFromJsonString,
        ),
      )
    }
  };
  ExternService(
    SKStore.ExternalPointer::create(service, deleteService),
    initialData.chill(),
    resourceBuilders.chill(),
    externalServices.chill(),
  )
}

@cpp_extern("SkipRuntime_deleteService")
@debug
native fun deleteService(service: UInt32): void;

@cpp_extern("SkipRuntime_Service__createGraph")
@debug
native fun createGraphOfService(
  resource: UInt32,
  collections: SKJSON.CJObject,
): SKJSON.CJObject;

class ExternService(
  eptr: SKStore.ExternalPointer,
  initialData_: Map<String, Data>,
  resourceBuilders_: Map<String, ResourceBuilder>,
  externalServices_: Map<String, ExternalService>,
) extends Service {
  fun initialData(): Map<String, Data> {
    this.initialData_
  }

  fun resourceBuilders(): Map<String, ResourceBuilder> {
    this.resourceBuilders_
  }

  fun externalServices(): Map<String, ExternalService> {
    this.externalServices_
  }
  //
  fun createGraph(inputs: Collections): Collections {
    names = createGraphOfService(this.eptr.value, collectionsByName(inputs));
    map = mutable Map[];
    names match {
    | SKJSON.CJObject(nfields) ->
      for (fieldName => field in nfields) {
        map![fieldName] = collectionForName(SKJSON.asString(field));
      }
    };
    CollectionsMap(map.chill())
  }
}

/************  ResourceBuilderMap ****************/

@export("SkipRuntime_ResourceBuilderMap__create")
fun createOfResourceBuilderMap(): mutable Map<String, ResourceBuilder> {
  mutable Map[]
}

@export("SkipRuntime_ResourceBuilderMap__add")
fun addOfResourceBuilderMap(
  builders: mutable Map<String, ResourceBuilder>,
  name: String,
  builder: ExternResourceBuilder,
): void {
  builders.add(name, builder)
}

/************  ExternalServiceMap ****************/

@export("SkipRuntime_ExternalServiceMap__create")
fun createOfExternalServiceMap(): mutable Map<String, ExternalService> {
  mutable Map[]
}

@export("SkipRuntime_ExternalServiceMap__add")
fun addOfExternalServiceMap(
  suppliers: mutable Map<String, ExternalService>,
  name: String,
  supplier: ExternalService,
): void {
  suppliers.add(name, supplier)
}

/************  Collection ****************/

@export("SkipRuntime_Collection__getArray")
fun getArrayOfCollection(
  collection: String,
  key: SKJSON.CJSON,
): SKJSON.CJArray {
  SKJSON.CJArray(collectionForNameJSON(collection).getArray(key))
}

@export("SkipRuntime_Collection__map")
fun mapOfCollection(collection: String, mapper: JSONMapper): String {
  collectionForNameJSON(collection).map(mapper).getId()
}

@export("SkipRuntime_Collection__mapReduce")
fun mapReduceOfCollection(
  collection: String,
  mapper: JSONMapper,
  reducer: JSONReducer,
): String {
  collectionForNameJSON(collection).mapReduce(mapper, reducer).getId()
}

fun intFromJSON(json: SKJSON.CJSON): Int {
  json match {
  | SKJSON.CJInt(v) -> v
  | _ -> invariant_violation("Must be an Int value.")
  }
}

@export("SkipRuntime_Collection__nativeMapReduce")
fun nativeMapReduce(
  collection: String,
  mapper: JSONMapper,
  reducer: String,
): String {
  collectionForNameJSON(collection)
    .nativeMapReduce(mapper, reducer, intFromJSON, intToJSON)
    .getId()
}

@export("SkipRuntime_Collection__reduce")
fun reduceOfCollection(collection: String, reducer: JSONReducer): String {
  collectionForNameJSON(collection).reduce(reducer).getId()
}

@export("SkipRuntime_Collection__nativeReduce")
fun nativeReduceOfCollection(collection: String, reducer: String): String {
  collectionForNameJSON(collection)
    .nativeReduce(reducer, intFromJSON, intToJSON)
    .getId()
}

@export("SkipRuntime_Collection__slice")
fun sliceOfCollection(collection: String, ranges: SKJSON.CJArray): String {
  collectionForNameJSON(collection)
    .sliced(
      ranges match {
      | SKJSON.CJArray(values) ->
        values.map(v -> {
          e = SKJSON.expectArray(v);
          (e[0], e[1])
        })
      },
    )
    .getId()
}

@export("SkipRuntime_Collection__take")
fun takeOfCollection(collection: String, limit: Int): String {
  collectionForNameJSON(collection).take(limit).getId()
}

@export("SkipRuntime_Collection__merge")
fun mergeOfCollection(collection: String, others: SKJSON.CJArray): String {
  collectionForNameJSON(collection)
    .merge(
      others match {
      | SKJSON.CJArray(values) ->
        values.map(c -> collectionForNameJSON(SKJSON.asString(c)))
      },
    )
    .getId()
}

@export("SkipRuntime_Collection__size")
fun sizeOfCollection(collection: String): Int {
  collectionForNameJSON(collection).size()
}

/************  LazyCollection ****************/

@export("SkipRuntime_LazyCollection__getArray")
fun getArrayOfLazyCollection(lazy: String, key: SKJSON.CJSON): SKJSON.CJArray {
  SKJSON.CJArray(lazyForNameJSON(lazy).getArray(key))
}

/************  Notifier ****************/

@cpp_extern("SkipRuntime_Notifier__subscribed")
@debug
native fun subscribedOfNotifier(notifier: UInt32): void;

@cpp_extern("SkipRuntime_Notifier__notify")
@debug
native fun notifyOfNotifier(
  notifier: UInt32,
  values: SKJSON.CJArray,
  watermark: String,
  updates: Int32,
): void;

@cpp_extern("SkipRuntime_Notifier__close")
@debug
native fun closeOfNotifier(notifier: UInt32): void;

@cpp_extern("SkipRuntime_deleteNotifier")
@debug
native fun deleteNotifier(notifier: UInt32): void;

@export("SkipRuntime_createNotifier")
fun createNotifier(notifier: UInt32): ExternNotifier {
  ExternNotifier(SKStore.ExternalPointer::create(notifier, deleteNotifier))
}

class ExternNotifier(eptr: SKStore.ExternalPointer) extends Notifier {
  fun subscribed(): void {
    subscribedOfNotifier(this.eptr.value)
  }

  fun notify(values: Array<Entry>, watermark: String, updates: Bool): void {
    notifyOfNotifier(
      this.eptr.value,
      SKJSON.CJArray(
        values.map(v -> {
          entry = castEntry<SKStore.Key, SKStore.File>(v);
          SKJSON.CJArray(
            Array[
              jsonFromKey(entry.key()),
              SKJSON.CJArray(entry.values.map(jsonFromFile)),
            ],
          )
        }),
      ),
      watermark,
      Int32::truncate(if (updates) 1 else 0),
    )
  }

  fun close(): void {
    closeOfNotifier(this.eptr.value)
  }
}

/************  Reducer ****************/

@cpp_extern("SkipRuntime_Reducer__add")
@debug
native fun addOfReducer(
  reducer: UInt32,
  acc: SKJSON.CJSON,
  value: SKJSON.CJSON,
): SKJSON.CJSON;

@cpp_extern("SkipRuntime_Reducer__remove")
@debug
native fun removeOfReducer(
  reducer: UInt32,
  acc: SKJSON.CJSON,
  value: SKJSON.CJSON,
): ?SKJSON.CJSON;

@cpp_extern("SkipRuntime_deleteReducer")
@debug
native fun deleteReducer(reducer: UInt32): void;

@export("SkipRuntime_createReducer")
fun createReducer(reducer: UInt32, initial: SKJSON.CJSON): JSONReducer {
  JSONReducer(SKStore.ExternalPointer::create(reducer, deleteReducer), initial)
}

class JSONReducer(
  eptr: SKStore.ExternalPointer,
) extends Reducer<SKJSON.CJSON, SKJSON.CJSON> {
  const kConverter: ValueConverter<SKJSON.CJSON> = JSONValueConverter();

  fun add(acc: SKJSON.CJSON, value: SKJSON.CJSON): SKJSON.CJSON {
    addOfReducer(this.eptr.value, acc, value)
  }

  fun remove(acc: SKJSON.CJSON, value: SKJSON.CJSON): ?SKJSON.CJSON {
    removeOfReducer(this.eptr.value, acc, value)
  }

  fun valueConverter(): SKStore.File ~> SKJSON.CJSON {
    static::kConverter.fromFile
  }

  fun accConverter(): ValueConverter<SKJSON.CJSON> {
    static::kConverter
  }
}

/************  Service Instance ****************/

@export("SkipRuntime_Runtime__createResource")
fun createResourceOfRuntime(
  identifier: String,
  resource: String,
  params: SKJSON.CJSON,
  executor: Executor,
): Float {
  SKStore.runWithResult(context ~> {
    _ = createReactiveResource(
      context,
      identifier,
      resource,
      JSONParams(params),
      executor,
    )
  }) match {
  | Success _ -> 0.0
  | Failure(err) -> getErrorHdl(err)
  }
}

@export("SkipRuntime_Runtime__getAll")
fun getAllOfRuntime(resource: String, params: SKJSON.CJSON): SKJSON.CJSON {
  SKStore.runWithResult(context ~> {
    res = getAll(context, resource, JSONParams(params));
    /* Ensure all resources closed at right time */
    updateContext(context);
    res
  }) match {
  | Success(result) ->
    fields = mutable Vector<(String, SKJSON.CJSON)>[
      (
        "payload",
        SKJSON.CJArray(
          result.values.entries.map(v -> {
            entry = castEntry<SKStore.Key, SKStore.File>(v);
            SKJSON.CJArray(
              Array[
                jsonFromKey(entry.key()),
                SKJSON.CJArray(entry.values.map(jsonFromFile)),
              ],
            )
          }),
        ),
      ),
      ("errors", SKJSON.CJArray(result.errors.map(jsonFromError))),
    ];
    SKJSON.CJObject(
      SKJSON.CJFields::create(fields.sortedBy(x ~> x.i0).toArray(), x -> x),
    )
  | Failure(err) -> SKJSON.CJFloat(getErrorHdl(err))
  }
}

@export("SkipRuntime_Runtime__getForKey")
fun getForKeyOfRuntime(
  resource: String,
  params: SKJSON.CJSON,
  key: SKJSON.CJSON,
): SKJSON.CJSON {
  SKStore.runWithResult(context ~> {
    res = getForKey(context, resource, JSONParams(params), JSONID(key));
    /* Ensure all resources closed at right time */
    updateContext(context);
    res
  }) match {
  | Success(result) ->
    fields = mutable Vector<(String, SKJSON.CJSON)>[
      ("payload", SKJSON.CJArray(result.values.map(jsonFromFile))),
      ("errors", SKJSON.CJArray(result.errors.map(jsonFromError))),
    ];
    SKJSON.CJObject(
      SKJSON.CJFields::create(fields.sortedBy(x ~> x.i0).toArray(), x -> x),
    )
  | Failure(err) -> SKJSON.CJFloat(getErrorHdl(err))
  };
}

@export("SkipRuntime_Runtime__closeResource")
fun closeResourceOfRuntime(identifier: String): Float {
  ServiceInstance.closeResourceInstance(identifier) match {
  | Success _ -> 0.0
  | Failure(err) -> getErrorHdl(err)
  };
}

@export("SkipRuntime_Runtime__subscribe")
fun subscribeOfRuntime(
  reactiveId: String,
  notifier: ExternNotifier,
  watermark: ?String,
): Int {
  SKStore.runWithResult(context ~> {
    subscribe(context, reactiveId, notifier, watermark)
  }) match {
  | Success(id) -> id
  | Failure(UnknownCollectionError _) -> -1
  | Failure(ResourceInstanceInUse _) -> -2
  | Failure(err) -> -getErrorHdl(err).toInt()
  };
}

@export("SkipRuntime_Runtime__unsubscribe")
fun unsubscribeOfRuntime(session: Int): Float {
  SKStore.runWithResult(context ~> {
    unsubscribe(context, session)
  }) match {
  | Success _ -> 0.0
  | Failure(err) -> getErrorHdl(err)
  };
}

@export("SkipRuntime_Runtime__update")
fun updateOfRuntime(
  input: String,
  values: SKJSON.CJArray,
  executor: Executor,
): Float {
  SKStore.runWithResult(context ~> {
    update(
      context,
      input,
      values match {
      | SKJSON.CJArray(vs) ->
        vs.map(v -> {
          e = SKJSON.expectArray(v);
          (JSONID(e[0]), SKJSON.expectArray(e[1]).map(v ~> JSONFile(v)))
        })
      },
      executor,
    )
  }) match {
  | Success _ -> 0.0
  | Failure(err) -> getErrorHdl(err)
  };
}

/************ Context ****************/

@export("SkipRuntime_Context__createLazyCollection")
fun lazyOfContext(compute: ExternLazyCompute): String {
  createLazyCollection(compute, kJSON_CONVERTERS).getId()
}

@export("SkipRuntime_Context__jsonExtract")
fun jsonExtractOfContext(
  from: SKJSON.CJObject,
  pattern: String,
): SKJSON.CJArray {
  SKJSON.CJArray(jsonExtract(from, pattern))
}

@export("SkipRuntime_Context__useExternalResource")
fun useExternalResource(
  service: String,
  identifier: String,
  params: SKJSON.CJSON,
): String {
  useExternalCollection(
    service,
    identifier,
    JSONParams(params),
    kJSON_CONVERTERS,
  ).getId()
}

/************ initService ****************/

@export("SkipRuntime_initService")
fun initSkipRuntimeService(service: Service, executor: Executor): Float {
  initService(service, executor) match {
  | Success _ -> 0.0
  | Failure(err) -> getErrorHdl(err)
  };
}

/************ closeService ****************/

@export("SkipRuntime_closeService")
fun closeSkipRuntimeService(): SKJSON.CJSON {
  closeService() match {
  | Success(handles) -> SKJSON.CJArray(handles.map(h -> SKJSON.CJFloat(h)))
  | Failure(err) -> SKJSON.CJFloat(getErrorHdl(err))
  };
}

class ExternalException(
  type: String,
  message: String,
  stack: String,
) extends .Exception {
  fun getMessage(): String {
    this.message
  }
}

@export("SkipRuntime_throwExternalException")
fun throwExternalException(type: String, message: String, stack: String): void {
  throw ExternalException(type, message, stack)
}

@export("SkipRuntime_getExceptionStack")
fun getExceptionStack(exn: .Exception): ?String {
  exn match {
  | ExternalException(_, _, stack) -> Some(stack)
  | _ -> None()
  }
}

@export("SkipRuntime_getExceptionType")
fun getExceptionType(exn: .Exception): String {
  exn match {
  | ExternalException(type, _, _) -> type
  | _ -> exn.getClassName()
  }
}

module end;
