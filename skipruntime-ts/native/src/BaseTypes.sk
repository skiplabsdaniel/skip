module SkipRuntime;

base class IError uses Show

base class KeyConverter<K: frozen> {
  fun fromKey(SKStore.Key): K;
  fun toKey(K): SKStore.Key;
}

base class ValueConverter<V: frozen> {
  fun fromFile(SKStore.File): V;
  fun toFile(V): SKStore.File;
}

base class ErrorConverter<E: frozen> {
  fun fromError(IError): E;
  fun toError(E): IError;
}

base class ParamsConverter<P: frozen> {
  fun fromParams(Parameters): P;
  fun toParams(P): Parameters;
}

class ConverterPair<K: frozen, V: frozen>(
  key: KeyConverter<K>,
  value: ValueConverter<V>,
) {
  fun fromSKStore(values: (SKStore.Key, Array<SKStore.File>)): (K, Array<V>) {
    (this.key.fromKey(values.i0), values.i1.map(this.value.fromFile))
  }

  fun toSKStore(values: (K, Array<V>)): (SKStore.Key, Array<SKStore.File>) {
    (this.key.toKey(values.i0), values.i1.map(this.value.toFile))
  }
}

base class Reducer<V1: frozen, V2: frozen>(initial: V2) {
  fun add(acc: V2, value: V1): V2;
  fun remove(acc: V2, value: V1): ?V2;
  fun valueConverter(): SKStore.File ~> V1;
  fun accConverter(): ValueConverter<V2>;
}

/**
 * The type of a reactive function mapping over an arbitrary collection.
 * For each key & values in the input collection (of type K1/V1 respectively),
 * produces some key/value pairs for the output collection (of type K2/V2 respectively)
 * @param key - a key found in the input collection
 * @param values - the values mapped to by `key` in the input collection
 * @returns an iterable of key/value pairs to output for the given input(s)
 */
base class Mapper<K1: frozen, V1: frozen, K2: frozen, V2: frozen> {
  fun mapEntry(
    key: K1,
    values: mutable SKStore.NonEmptyIterator<V1>,
  ): mutable Iterator<(K2, V2)>;

  fun converters(): ConverterPair<K2, V2>;
}

base class LazyCompute<K: frozen, V: frozen> {
  fun compute(self: LazyCollection<K, V>, key: K): Array<V>;
}

base class Writer {
  fun getId(): String;

  fun update(
    values: Array<(SKStore.Key, Array<SKStore.File>)>,
    isInit: Bool,
  ): Result<void, .Exception>;

  fun error(error: IError): Result<void, .Exception>;

  fun loading(): Result<void, .Exception>;
}

base class StatusWriter {
  fun status(context: mutable SKStore.Context, status: Status<IError>): void;
}

base class ExternalService {
  fun subscribe(
    instance: String,
    writer: Writer,
    resource: String,
    params: Parameters,
  ): void;

  fun unsubscribe(instance: String): void;

  fun shutdown(): Float;
}

base class TExternalService<K: frozen, V: frozen, E: frozen, P: frozen> extends
  ExternalService,
{
  fun subscribeTo(
    instance: String,
    writer: TWriter<K, V, E>,
    resource: String,
    params: P,
  ): void;

  fun subscribe(
    instance: String,
    writer: Writer,
    resource: String,
    params: Parameters,
  ): void {
    tWriter = TWriter<K, V, E>(
      writer,
      this.converters(),
      this.errorConverter(),
    );
    this.subscribeTo(
      instance,
      tWriter,
      resource,
      this.paramsConverter().fromParams(params),
    )
  }

  fun converters(): ConverterPair<K, V>;
  fun errorConverter(): ErrorConverter<E>;
  fun paramsConverter(): ParamsConverter<P>;
}

base class Parameters uses Orderable, Show

base class Resource {
  fun instantiate(
    collections: Map<String, Collection<SKStore.Key, SKStore.File>>,
  ): Collection<SKStore.Key, SKStore.File>;
}

base class Data {
  fun unTyped(): InitialData<SKStore.Key, SKStore.File>;
}

class InitialData<K: frozen, V: frozen>(
  values: Array<(K, Array<V>)>,
  converters: ConverterPair<K, V>,
) extends Data {
  fun unTyped(): InitialData<SKStore.Key, SKStore.File> {
    InitialData(
      this.values.map(v ->
        (
          SKStore.Key::unTyped(this.converters.key.toKey(v.i0)),
          v.i1.map(this.converters.value.toFile).map(unTypedFile),
        )
      ),
      kNOTYPE_CONVERTERS,
    )
  }
}

base class Service {
  fun eachInitialData((String, Data) -> void): void;
  fun buildResource(name: String, parameters: Parameters): Resource;
  fun externalServices(): Map<String, ExternalService>;

  fun createGraph(
    inputCollections: Map<String, Collection<SKStore.Key, SKStore.File>>,
  ): Map<String, Collection<SKStore.Key, SKStore.File>>;
}

base class Collections

base class CollectionsConverter<CS: Collections> {
  fun fromMap(Map<String, Collection<SKStore.Key, SKStore.File>>): CS;
  fun toMap(CS): Map<String, Collection<SKStore.Key, SKStore.File>>;
}

base class TResource<K: frozen, V: frozen, CS: Collections> {
  fun instantiate(collections: CS): Collection<K, V>;
}

base class TService<CI: Collections, CO: Collections> {
  fun createGraph(collections: CI): CO;
}

base class Request {
  children =
  | Identifier(id: String)
}

base class Checker extends Request {
  fun check(request: String): void;
}

base class Notifier<K: frozen, V: frozen> {
  fun subscribed(): void;

  fun notify(
    values: Array<(K, Array<V>)>,
    watermark: String,
    updates: Bool,
  ): void;

  fun close(): void;
}

/** Prevent unused pattern */

class DummyChecker() extends Checker {
  fun check(_request: String): void {
    invariant_violation("dummy");
  }
}

module end;
