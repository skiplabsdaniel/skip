module SkipRuntime;

base class IError uses Show
base class Parameters uses Orderable, Show
base class Collections

base class KeyConverter<K: frozen> {
  fun fromKey(SKStore.Key): K;
  fun toKey(K): SKStore.Key;
}

base class ValueConverter<V: frozen> {
  fun fromFile(SKStore.File): V;
  fun toFile(V): SKStore.File;
}

base class ErrorConverter<E: frozen> {
  fun fromError(IError): E;
  fun toError(E): IError;
}

base class ParamsConverter<P: frozen> {
  fun fromParams(Parameters): P;
  fun toParams(P): Parameters;
}

class ConverterPair<K: frozen, V: frozen>(
  key: KeyConverter<K>,
  value: ValueConverter<V>,
) {
  fun fromSKStore(values: (SKStore.Key, Array<SKStore.File>)): (K, Array<V>) {
    (this.key.fromKey(values.i0), values.i1.map(this.value.fromFile))
  }

  fun toSKStore(values: (K, Array<V>)): (SKStore.Key, Array<SKStore.File>) {
    (this.key.toKey(values.i0), values.i1.map(this.value.toFile))
  }
}

base class Reducer<V1: frozen, V2: frozen>(initial: V2) {
  fun add(acc: V2, value: V1): V2;
  fun remove(acc: V2, value: V1): ?V2;
  fun valueConverter(): SKStore.File ~> V1;
  fun accConverter(): ValueConverter<V2>;
}

/**
 * The type of a reactive function mapping over an arbitrary collection.
 * For each key & values in the input collection (of type K1/V1 respectively),
 * produces some key/value pairs for the output collection (of type K2/V2 respectively)
 * @param key - a key found in the input collection
 * @param values - the values mapped to by `key` in the input collection
 * @returns an iterable of key/value pairs to output for the given input(s)
 */
base class Mapper<K1: frozen, V1: frozen, K2: frozen, V2: frozen> {
  fun mapEntry(
    key: K1,
    values: mutable SKStore.NonEmptyIterator<V1>,
  ): mutable Iterator<(K2, V2)>;

  fun converters(): ConverterPair<K2, V2>;
}

base class LazyCompute<K: frozen, V: frozen> {
  fun compute(self: LazyCollection<K, V>, key: K): Array<V>;
}

base class Writer {
  fun getId(): String;

  fun update(
    values: Array<(SKStore.Key, Array<SKStore.File>)>,
    isInit: Bool,
  ): Result<void, .Exception>;

  fun error(error: IError): Result<void, .Exception>;

  fun loading(): Result<void, .Exception>;
}

base class StatusWriter {
  fun status(context: mutable SKStore.Context, status: Status<IError>): void;
}

base class ExternalService {
  fun subscribe(
    instance: String,
    writer: Writer,
    resource: String,
    params: Parameters,
  ): void;

  fun unsubscribe(instance: String): void;

  fun shutdown(): Float;
}

base class Resource {
  fun materialize(
    collections: Map<String, Collection<SKStore.Key, SKStore.File>>,
  ): Collection<SKStore.Key, SKStore.File>;
}

base class ResourceBuilder {
  fun produce(params: Parameters): Resource;
}

base class Data {
  fun keyValues(): Array<(SKStore.Key, Array<SKStore.File>)>;
}

class InitialData<K: frozen, V: frozen>(
  values: Array<(K, Array<V>)>,
  converters: ConverterPair<K, V>,
) extends Data {
  fun keyValues(): Array<(SKStore.Key, Array<SKStore.File>)> {
    this.values.map(v ->
      (
        SKStore.Key::unTyped(this.converters.key.toKey(v.i0)),
        v.i1.map(this.converters.value.toFile).map(unTypedFile),
      )
    )
  }
}

class EmptyData() extends Data {
  fun keyValues(): Array<(SKStore.Key, Array<SKStore.File>)> {
    Array[]
  }
}

base class Service {
  fun initialData(): Map<String, Data>;
  fun resourceBuilders(): Map<String, ResourceBuilder>;
  fun externalServices(): Map<String, ExternalService>;

  fun createGraph(
    inputCollections: Map<String, Collection<SKStore.Key, SKStore.File>>,
  ): Map<String, Collection<SKStore.Key, SKStore.File>>;
}

base class Request {
  children =
  | Identifier(id: String)
}

base class Checker extends Request {
  fun check(request: String): void;
}

base class Notifier<K: frozen, V: frozen> {
  fun subscribed(): void;

  fun notify(
    values: Array<(K, Array<V>)>,
    watermark: String,
    updates: Bool,
  ): void;

  fun close(): void;
}

// ************ Typed ************************

base class TResourceBuilder<P: frozen> extends ResourceBuilder {
  fun build(params: P): Resource;
  fun fromParameters(params: Parameters): P;

  fun produce(params: Parameters): Resource {
    this.build(this.fromParameters(params))
  }
}

base class TResource<K: frozen, V: frozen, CS: Collections> extends Resource {
  fun materialize(
    collections: Map<String, Collection<SKStore.Key, SKStore.File>>,
  ): Collection<SKStore.Key, SKStore.File> {
    this.instantiate(this.fromMap(collections)).unTyped()
  }

  fun instantiate(collections: CS): Collection<K, V>;
  fun fromMap(Map<String, Collection<SKStore.Key, SKStore.File>>): CS;
}

base class TService<CI: Collections, CO: Collections> extends Service {
  fun createTypedGraph(collections: CI): CO;

  fun createGraph(
    inputCollections: Map<String, Collection<SKStore.Key, SKStore.File>>,
  ): Map<String, Collection<SKStore.Key, SKStore.File>> {
    this.toMap(this.createTypedGraph(this.fromMap(inputCollections)))
  }

  fun fromMap(Map<String, Collection<SKStore.Key, SKStore.File>>): CI;
  fun toMap(CO): Map<String, Collection<SKStore.Key, SKStore.File>>;
}

base class TExternalService<K: frozen, V: frozen, E: frozen, P: frozen>(
  toSKStore: ((K, Array<V>)) ~> (SKStore.Key, Array<SKStore.File>),
  toError: E ~> IError,
  fromParameters: Parameters ~> P,
) extends ExternalService {
  fun subscribeTo(
    instance: String,
    writer: TWriter<K, V, E>,
    resource: String,
    params: P,
  ): void;

  fun subscribe(
    instance: String,
    writer: Writer,
    resource: String,
    params: Parameters,
  ): void {
    tWriter = TWriter<K, V, E>(writer, this.toSKStore, this.toError);
    this.subscribeTo(instance, tWriter, resource, this.fromParameters(params))
  }
}

// Prevent unused pattern
class DummyChecker() extends Checker {
  fun check(_request: String): void {
    invariant_violation("dummy");
  }
}

module end;
